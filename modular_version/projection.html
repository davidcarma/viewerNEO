<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Projection</title>
    <link rel="stylesheet" href="css/components/thumbnail.css">
    <link rel="stylesheet" href="css/components/thumbnail-panel.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        header {
            background-color: #111;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }
        h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        .controls {
            padding: 10px 20px;
            background-color: #333;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        button {
            background-color: #444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        button:active {
            background-color: #666;
        }
        .content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            margin-top: 10px; /* Add some spacing between controls and content */
        }
        .image-container {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #imageDisplay {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .status-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
            width: 350px;
        }
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
            display: none;
        }
        .debug-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            max-width: 80%;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            color: #aaffaa;
        }
        
        /* Adjust content when thumbnails are visible */
        .content.with-thumbnails {
            margin-left: 250px;
            transition: margin-left 0.25s ease;
            will-change: margin-left;
            padding-top: 0; /* No need for extra padding since panel is below controls now */
        }
        
        /* Make the thumbnail panel wider for projection page */
        #thumbnail-panel {
            width: 250px !important;
            top: 120px !important; /* Position below the header + controls */
            z-index: 200; /* Ensure it appears above other content */
            height: calc(100vh - 120px) !important; /* Adjust height to account for header and controls */
            position: fixed; /* Ensure fixed positioning */
            left: -250px; /* Start offscreen */
            transition: left 0.25s ease; /* Smooth transition */
            background-color: #333; /* Match app background */
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.4); /* Add shadow for depth */
            overflow-y: auto; /* Allow scrolling */
        }
        
        /* Active state for the panel */
        #thumbnail-panel.active {
            left: 0 !important; /* Slide in from the left */
        }
        
        /* Ensure the toggle handle is visible on this page */
        #thumbnail-toggle-handle {
            display: flex !important;
            left: 0px;
            top: 120px !important; /* Align with the top of the thumbnail panel */
            z-index: 201; /* Slightly higher than the panel */
            position: fixed;
            width: 12px;
            height: 40px;
            background-color: #444;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            border-radius: 0 4px 4px 0;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            transition: left 0.25s ease;
            border: none;
            outline: none;
        }
        
        /* Position the handle correctly when panel is open */
        #thumbnail-panel.active ~ #thumbnail-toggle-handle {
            left: 250px !important;
            top: 120px !important; /* Keep alignment correct when panel is open */
        }
        
        /* Add a visual indicator to the handle */
        #thumbnail-toggle-handle::before {
            content: '';
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 6px solid #aaa;
        }
        
        /* Flip the indicator when panel is open */
        #thumbnail-panel.active ~ #thumbnail-toggle-handle::before {
            border-right: none;
            border-left: 6px solid #aaa;
        }
        
        /* Improve thumbnail styling for projection page */
        .thumbnail-item {
            width: 230px;
            margin: 10px auto;
            border-radius: 6px;
            background: #222;
        }
        
        .thumbnail-item img {
            height: 150px;
            object-fit: contain;
            background: #111;
        }
        
        /* Improve thumbnail label styling */
        .thumbnail-item div {
            font-size: 11px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            background: rgba(0,0,0,0.7);
            padding: 6px;
            text-align: left;
        }
        
        /* Style for active thumbnail */
        .thumbnail-item.active {
            border: 2px solid #ff0059;
            box-shadow: 0 0 8px rgba(255,0,89,0.4);
        }
        
        /* Batch header styling */
        .batch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #1a1a1a;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 0;
            opacity: 1; /* Ensure full visibility */
            visibility: visible; /* Explicitly ensure visibility */
        }
        
        .batch-header .chevron {
            transition: transform 0.2s ease;
        }
        
        .batch-header.collapsed .chevron {
            transform: rotate(-90deg);
        }
        
        .batch-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .batch-title {
            font-size: 13px;
            font-weight: 500;
        }
        
        .batch-count {
            background: rgba(80, 80, 80, 0.5);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            min-width: 16px;
            text-align: center;
        }
        
        .batch-content {
            overflow: hidden;
            max-height: 3000px; /* Arbitrary large value */
            display: block; /* Ensure it's explicitly visible */
            transition: none; /* Disable transition initially */
        }
        
        .batch-content.collapsed {
            max-height: 0;
        }
        
        /* Enable transitions after initial load */
        .transitions-enabled .batch-content {
            transition: max-height 0.3s ease;
        }
        
        .batch-divider {
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
        }
        
        /* Sync status indicator */
        .sync-status {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 5px 10px;
            font-size: 11px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .sync-status.active {
            opacity: 0.6;
        }
        
        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #4CAF50;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Image Projection</h1>
        <div>
            <button id="backToViewer" style="background-color: #4CAF50; border-color: #3d8b40; color: white;">Back to Viewer</button>
        </div>
    </header>
    
    <div class="controls">
        <button id="loadCurrentImage" style="background-color: #2196F3; border-color: #1976D2; color: white;">Load Current Image</button>
        <button id="loadAllImages" style="background-color: #9c27b0; border-color: #7b1fa2; color: white;">Load All Images</button>
        <button id="clear-db-btn" style="background-color: #f44336; border-color: #d32f2f; color: white;">Clear DB</button>
        <button id="applyProcessing" style="background-color: #ff9800; border-color: #f57c00; color: white;">Apply Processing (Demo)</button>
        <button id="showDebug" style="background-color: #795548; border-color: #5d4037; color: white;">Show Debug Info</button>
        <button id="toggle-thumbnails" style="background-color: #00BCD4; border-color: #0097A7; color: white;">Show Thumbnails</button>
    </div>
    
    <div id="thumbnail-panel">
        <div class="thumbnail-header">
            <h3>Images</h3>
            <button id="close-thumbnails" class="icon-btn" style="background-color: #f44336; border-color: #d32f2f;" aria-label="Close thumbnails">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div id="thumbnails-container"></div>
    </div>
    
    <!-- Thumbnail toggle handle -->
    <div id="thumbnail-toggle-handle" role="button" aria-label="Toggle thumbnail panel" title="Toggle thumbnails"></div>
    
    <div class="content">
        <div class="image-container">
            <img id="imageDisplay" alt="No image loaded">
        </div>
        
        <div class="status-container">
            <div id="imageInfo">No image loaded</div>
        </div>
        
        <div id="debugLog" class="debug-log" style="display: none;"></div>
        
        <div class="loading">Loading...</div>
        
        <div class="sync-status" id="syncStatus">
            <div class="sync-indicator"></div>
            <span>Syncing with database...</span>
        </div>
    </div>
    
    <script type="module">
        import { getCurrentImage, createImageFromRecord } from './src/services/db/currentImageStore.js';
        import { getAllImagesMetadata, getImageFromDb, clearImageDatabase } from './src/services/db/imageStore.js';
        
        // Import the CURRENT_IMAGE_KEY constant for filtering out current image from thumbnails
        const CURRENT_IMAGE_KEY = 'current_image';
        
        const loadingIndicator = document.querySelector('.loading');
        const imageDisplay = document.getElementById('imageDisplay');
        const imageInfo = document.getElementById('imageInfo');
        const debugLog = document.getElementById('debugLog');
        const loadButton = document.getElementById('loadCurrentImage');
        const applyProcessingButton = document.getElementById('applyProcessing');
        const backButton = document.getElementById('backToViewer');
        const showDebugButton = document.getElementById('showDebug');
        const thumbnailPanel = document.getElementById('thumbnail-panel');
        const thumbnailsContainer = document.getElementById('thumbnails-container');
        const toggleThumbnailsBtn = document.getElementById('toggle-thumbnails');
        const toggleHandle = document.getElementById('thumbnail-toggle-handle');
        const closeThumbnailsBtn = document.getElementById('close-thumbnails');
        const contentElement = document.querySelector('.content');
        
        // Debug logging
        function log(message, data) {
            console.log(message, data);
            const logEntry = document.createElement('div');
            logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
            if (data) {
                try {
                    logEntry.textContent += `: ${JSON.stringify(data)}`;
                } catch (e) {
                    logEntry.textContent += `: ${data}`;
                }
            }
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            log('Projection page loaded');
            
            // Set up thumbnail panel toggle functionality
            toggleThumbnailsBtn.addEventListener('click', toggleThumbnailPanel);
            closeThumbnailsBtn.addEventListener('click', toggleThumbnailPanel);
            toggleHandle.addEventListener('click', toggleThumbnailPanel);
            
            // Load thumbnails
            await loadThumbnails();
            
            // Show thumbnail panel by default
            toggleThumbnailPanel();
            
            // Try to load the current image automatically on page load
            setTimeout(async () => {
                const imageLoaded = await loadCurrentImage();
                if (!imageLoaded) {
                    // If no current image exists, try to load the first image from the first batch
                    // (which will now exclude the current image due to our loadThumbnails modification)
                    const firstThumbnail = thumbnailsContainer.querySelector('.thumbnail-item');
                    if (firstThumbnail) {
                        const imageId = firstThumbnail.dataset.imageId;
                        if (imageId) {
                            loadImageById(imageId);
                        }
                    }
                }
                
                // Enable transitions after page content has loaded
                setTimeout(() => {
                    document.body.classList.add('transitions-enabled');
                    log('Transitions enabled');
                }, 500);
            }, 100);
            
            // Start database polling for updates
            startDatabasePolling();
        });
        
        // Toggle thumbnail panel
        function toggleThumbnailPanel() {
            thumbnailPanel.classList.toggle('active');
            contentElement.classList.toggle('with-thumbnails');
            
            if (thumbnailPanel.classList.contains('active')) {
                toggleThumbnailsBtn.textContent = 'Hide Thumbnails';
            } else {
                toggleThumbnailsBtn.textContent = 'Show Thumbnails';
            }
        }
        
        // Load thumbnails from IndexedDB
        async function loadThumbnails() {
            try {
                log('Loading thumbnails from IndexedDB');
                
                // Store collapsed states before clearing
                const collapsedBatchStates = new Map();
                document.querySelectorAll('.batch-header').forEach(header => {
                    const batchTitle = header.querySelector('.batch-title')?.textContent;
                    if (batchTitle) {
                        collapsedBatchStates.set(batchTitle, header.classList.contains('collapsed'));
                    }
                });
                
                // Clear existing thumbnails
                thumbnailsContainer.innerHTML = '';
                
                // Get all images from IndexedDB
                const allImages = await getAllImagesMetadata();
                
                if (!allImages || allImages.length === 0) {
                    log('No images found in IndexedDB');
                    thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images found</div>';
                    return;
                }
                
                log(`Found ${allImages.length} images in IndexedDB`);
                
                // Filter out the special "current_image" entry to avoid duplication
                // since it's already displayed in the main view
                const filteredImages = allImages.filter(metadata => metadata.id !== CURRENT_IMAGE_KEY);
                
                if (filteredImages.length === 0) {
                    thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No additional images available</div>';
                    return;
                }
                
                // Group images by batch ID
                const batchMap = new Map();
                
                filteredImages.forEach(metadata => {
                    const batchId = metadata.batchId || 'default';
                    
                    if (!batchMap.has(batchId)) {
                        batchMap.set(batchId, []);
                    }
                    
                    batchMap.get(batchId).push(metadata);
                });
                
                // Create a batch element for each batch
                for (const [batchId, imagesList] of batchMap.entries()) {
                    // Sort images by timestamp
                    imagesList.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Create batch header
                    const batchHeader = document.createElement('div');
                    batchHeader.className = 'batch-header';
                    
                    // Ensure immediate visibility with inline styles
                    batchHeader.style.display = 'flex';
                    batchHeader.style.visibility = 'visible';
                    batchHeader.style.opacity = '1';
                    
                    // Create left side container for title and count
                    const leftSide = document.createElement('div');
                    leftSide.className = 'batch-info';
                    
                    // Create title
                    const title = document.createElement('span');
                    title.className = 'batch-title';
                    const batchTitle = `Batch ${batchMap.size > 1 ? Array.from(batchMap.keys()).indexOf(batchId) + 1 : ''}`;
                    title.textContent = batchTitle;
                    leftSide.appendChild(title);
                    
                    // Add count badge
                    const count = document.createElement('span');
                    count.className = 'batch-count';
                    count.textContent = imagesList.length;
                    leftSide.appendChild(count);
                    
                    batchHeader.appendChild(leftSide);
                    
                    // Add chevron icon for expand/collapse
                    const chevron = document.createElement('span');
                    chevron.className = 'chevron';
                    chevron.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>';
                    batchHeader.appendChild(chevron);
                    
                    // Create batch content
                    const batchContent = document.createElement('div');
                    batchContent.className = 'batch-content';
                    
                    // Create reference between header and content elements
                    batchHeader.dataset.contentId = `batch-content-${batchId}`;
                    batchContent.id = `batch-content-${batchId}`;
                    
                    // Only apply collapsed state if explicitly found in the stored states
                    // Otherwise, default to expanded (not collapsed)
                    const wasCollapsed = collapsedBatchStates.has(batchTitle) && collapsedBatchStates.get(batchTitle) === true;
                    if (wasCollapsed) {
                        batchHeader.classList.add('collapsed');
                        batchContent.classList.add('collapsed');
                    }
                    
                    // Add toggle functionality
                    batchHeader.addEventListener('click', (event) => {
                        // Toggle collapsed class on this specific header
                        batchHeader.classList.toggle('collapsed');
                        
                        // Toggle collapsed class on the paired batch content using the reference
                        const contentId = batchHeader.dataset.contentId;
                        const content = document.getElementById(contentId);
                        if (content) {
                            content.classList.toggle('collapsed');
                        }
                        
                        // Log toggle action for debugging
                        log('Batch header toggled', {
                            batchTitle,
                            isCollapsed: batchHeader.classList.contains('collapsed'),
                            contentId
                        });
                        
                        // Prevent event bubbling
                        event.stopPropagation();
                    });
                    
                    thumbnailsContainer.appendChild(batchHeader);
                    
                    // Create thumbnails for each image
                    for (const imageMetadata of imagesList) {
                        if (!imageMetadata.hasBlob) continue;
                        
                        const thumbnailItem = document.createElement('div');
                        thumbnailItem.className = 'thumbnail-item';
                        thumbnailItem.dataset.imageId = imageMetadata.id;
                        
                        const imgEl = document.createElement('img');
                        imgEl.alt = imageMetadata.filename;
                        imgEl.loading = 'lazy';
                        
                        // Use placeholder initially
                        const placeholderSrc = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiMxMTExMTEiLz48cGF0aCBkPSJNMzUgMjVINjVDNjguMyAyNSA3MSAyNy43IDcxIDMxVjY5QzcxIDcyLjMgNjguMyA3NSA2NSA3NUgzNUMzMS43IDc1IDI5IDcyLjMgMjkgNjlWMzFDMjkgMjcuNyAzMS43IDI1IDM1IDI1WiIgc3Ryb2tlPSIjNTU1IiBzdHJva2Utd2lkdGg9IjIiLz48Y2lyY2xlIGN4PSI0MCIgY3k9IjQwIiByPSI1IiBmaWxsPSIjNTU1Ii8+PHBhdGggZD0iTTMwIDYwTDQwIDUwTDUwIDYwTDYwIDUwTDcwIDYwVjcwSDMwVjYwWiIgZmlsbD0iIzU1NSIvPjwvc3ZnPg==';
                        imgEl.src = placeholderSrc;
                        
                        thumbnailItem.appendChild(imgEl);
                        
                        // Create a more detailed label with filename and size
                        const label = document.createElement('div');
                        let labelText = imageMetadata.filename || 'Unnamed image';
                        
                        // Add file size if available
                        if (imageMetadata.blobSize) {
                            labelText += ` (${formatFileSize(imageMetadata.blobSize)})`;
                        }
                        
                        // Add dimensions if available
                        if (imageMetadata.dimensions) {
                            labelText += `<br>${imageMetadata.dimensions.width || '?'} × ${imageMetadata.dimensions.height || '?'} px`;
                        }
                        
                        label.innerHTML = labelText;
                        thumbnailItem.appendChild(label);
                        
                        // Add click event to load the image
                        thumbnailItem.addEventListener('click', () => loadImageById(imageMetadata.id));
                        
                        batchContent.appendChild(thumbnailItem);
                        
                        // Load the actual thumbnail asynchronously
                        loadThumbnailImage(imageMetadata.id, imgEl);
                    }
                    
                    thumbnailsContainer.appendChild(batchContent);
                    
                    // Add divider after each batch except the last one
                    if (Array.from(batchMap.keys()).indexOf(batchId) < batchMap.size - 1) {
                        const divider = document.createElement('div');
                        divider.className = 'batch-divider';
                        thumbnailsContainer.appendChild(divider);
                    }
                }
                
                // Wait a moment for DOM to update, then ensure batch headers are visible
                setTimeout(() => {
                    document.querySelectorAll('.batch-header').forEach(header => {
                        // Ensure batch headers are properly styled
                        header.style.visibility = 'visible';
                        header.style.display = 'flex';
                        header.style.opacity = '1';
                    });
                    log('Batch headers refreshed and made visible');
                }, 50);
                
            } catch (error) {
                log('Error loading thumbnails', error.message);
                console.error('Error loading thumbnails:', error);
                thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">Error loading thumbnails</div>';
            }
        }
        
        // Load thumbnail image from database
        async function loadThumbnailImage(imageId, imgElement) {
            try {
                const imageRecord = await getImageFromDb(imageId);
                if (imageRecord && imageRecord.imageBlob) {
                    const objectUrl = URL.createObjectURL(imageRecord.imageBlob);
                    imgElement.src = objectUrl;
                    imgElement.dataset.objectUrl = objectUrl;
                }
            } catch (error) {
                console.error(`Error loading thumbnail for image ${imageId}:`, error);
            }
        }
        
        // Load image by ID from IndexedDB
        async function loadImageById(imageId) {
            try {
                // Show loading indicator
                loadingIndicator.style.display = 'flex';
                loadingIndicator.textContent = 'Loading selected image...';
                
                log(`Loading image ${imageId} from IndexedDB`);
                
                // Store current image ID for sync detection
                currentImageId = imageId;
                
                // Highlight the selected thumbnail
                const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                thumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('active');
                    
                    // The current image may not be in thumbnails after our filtering
                    if (thumbnail.dataset.imageId === imageId) {
                        thumbnail.classList.add('active');
                        
                        // Scroll to the selected thumbnail
                        thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                // Get the image from IndexedDB
                const imageRecord = await getImageFromDb(imageId);
                
                if (!imageRecord) {
                    log(`Image ${imageId} not found in IndexedDB`);
                    imageInfo.textContent = 'Image not found in database.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                // Store the timestamp for change detection
                currentImageTimestamp = imageRecord.timestamp || Date.now();
                
                if (!imageRecord.imageBlob) {
                    log(`Image ${imageId} has no blob data`);
                    imageInfo.textContent = 'Error: Image record exists but contains no image data.';
                    loadingIndicator.style.display = 'none';
                    return;
                }
                
                // Create an image element from the blob
                const img = await createImageFromRecord(imageRecord);
                
                // Display the image
                const objectUrl = img.src;
                imageDisplay.src = objectUrl;
                
                // Wait for the image to load
                imageDisplay.onload = () => {
                    // Update image info
                    imageInfo.innerHTML = `
                        <strong>Image loaded successfully</strong><br>
                        Filename: ${imageRecord.filename}<br>
                        Size: ${imageRecord.dimensions.width} x ${imageRecord.dimensions.height} px<br>
                        File Type: ${imageRecord.fileType || 'Unknown'}<br>
                        File Size: ${imageRecord.imageBlob.size ? formatFileSize(imageRecord.imageBlob.size) : 'Unknown'}<br>
                        Last Modified: ${new Date(imageRecord.timestamp).toLocaleString()}
                    `;
                    
                    loadingIndicator.style.display = 'none';
                };
                
                imageDisplay.onerror = (e) => {
                    log('Error displaying image', e);
                    imageInfo.textContent = `Error displaying image. See debug info for details.`;
                    loadingIndicator.style.display = 'none';
                };
                
            } catch (error) {
                log('Error loading image', error.message);
                console.error('Error loading image:', error);
                imageInfo.textContent = `Error loading image: ${error.message}`;
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Set up button handlers
        loadButton.addEventListener('click', loadCurrentImage);
        document.getElementById('loadAllImages').addEventListener('click', loadAllImagesFromDb);
        document.getElementById('clear-db-btn').addEventListener('click', clearDatabase);
        backButton.addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        
        // Toggle debug info
        showDebugButton.addEventListener('click', () => {
            if (debugLog.style.display === 'none') {
                debugLog.style.display = 'block';
                showDebugButton.textContent = 'Hide Debug Info';
            } else {
                debugLog.style.display = 'none';
                showDebugButton.textContent = 'Show Debug Info';
            }
        });
        
        // Apply a simple visual processing effect as a demo
        applyProcessingButton.addEventListener('click', () => {
            if (!imageDisplay.src || imageDisplay.src.endsWith('No image loaded')) {
                alert('Please load an image first');
                return;
            }
            
            applyDemoProcessing();
        });
        
        // Load the current image from IndexedDB
        async function loadCurrentImage() {
            try {
                // Show loading indicator
                loadingIndicator.style.display = 'flex';
                loadingIndicator.textContent = 'Loading image from IndexedDB...';
                
                log('Requesting image from IndexedDB');
                
                // Get the current image from IndexedDB
                const imageRecord = await getCurrentImage();
                
                if (!imageRecord) {
                    log('No image record found in IndexedDB');
                    imageInfo.textContent = 'No image found in storage. Please load an image in the main viewer first.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                log('Retrieved image record', {
                    id: imageRecord.id,
                    filename: imageRecord.filename,
                    hasBlobData: !!imageRecord.imageBlob,
                    blobSize: imageRecord.imageBlob?.size,
                    dimensions: imageRecord.dimensions
                });
                
                // Store the current image ID for sync detection
                currentImageId = imageRecord.id;
                
                if (!imageRecord.imageBlob) {
                    log('Error: Image record has no blob data');
                    imageInfo.textContent = 'Error: Image record exists but contains no image data.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                // Highlight the current image in thumbnails if it exists
                const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                thumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('active');
                    
                    // After our filtering, the current image shouldn't exist in thumbnails
                    // This check remains only for backward compatibility
                    if (thumbnail.dataset.imageId === imageRecord.id) {
                        thumbnail.classList.add('active');
                        
                        // Scroll to the selected thumbnail
                        thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                // Create an image element from the blob
                log('Creating image element from blob', {
                    type: imageRecord.imageBlob.type,
                    size: imageRecord.imageBlob.size
                });
                
                const img = await createImageFromRecord(imageRecord);
                log('Image created from blob', {
                    width: img.width,
                    height: img.height,
                    complete: img.complete
                });
                
                // Display the image
                const objectUrl = img.src;
                imageDisplay.src = objectUrl;
                
                // Wait for the image to load
                imageDisplay.onload = () => {
                    log('Image loaded and displayed', {
                        naturalWidth: imageDisplay.naturalWidth,
                        naturalHeight: imageDisplay.naturalHeight
                    });
                    
                    // Update image info
                    imageInfo.innerHTML = `
                        <strong>Image loaded successfully</strong><br>
                        Filename: ${imageRecord.filename}<br>
                        Size: ${imageRecord.dimensions.width} x ${imageRecord.dimensions.height} px<br>
                        File Type: ${imageRecord.fileType || 'Unknown'}<br>
                        File Size: ${imageRecord.imageBlob.size ? formatFileSize(imageRecord.imageBlob.size) : 'Unknown'}<br>
                        Last Modified: ${new Date(imageRecord.timestamp).toLocaleString()}
                    `;
                    
                    loadingIndicator.style.display = 'none';
                };
                
                imageDisplay.onerror = (e) => {
                    log('Error displaying image', e);
                    imageInfo.textContent = `Error displaying image. See debug info for details.`;
                    loadingIndicator.style.display = 'none';
                    return false;
                };
                
                return true;
                
            } catch (error) {
                log('Error loading image from IndexedDB', error.message);
                console.error('Error loading image from IndexedDB:', error);
                imageInfo.textContent = `Error loading image: ${error.message}`;
                loadingIndicator.style.display = 'none';
                return false;
            }
        }
        
        // Load all images from IndexedDB
        async function loadAllImagesFromDb() {
            log('Loading all images from database');
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Loading all images...';
            
            try {
                // Get all images metadata
                const allImages = await getAllImagesMetadata();
                
                if (!allImages || allImages.length === 0) {
                    log('No images found in database');
                    imageInfo.textContent = 'No images found in database.';
                    loadingIndicator.style.display = 'none';
                    return;
                }
                
                log(`Found ${allImages.length} images in database`);
                
                // Reset thumbnails
                await loadThumbnails();
                
                // Select the first image with a blob, excluding the current image
                const imagesWithBlobs = allImages
                    .filter(img => img.hasBlob && img.id !== CURRENT_IMAGE_KEY);
                
                if (imagesWithBlobs.length > 0) {
                    loadImageById(imagesWithBlobs[0].id);
                } else {
                    log('No images with blobs found');
                    imageInfo.textContent = 'No valid images found in database.';
                    loadingIndicator.style.display = 'none';
                }
            } catch (error) {
                log('Error loading all images', error.message);
                console.error('Error loading all images:', error);
                imageInfo.textContent = `Error loading images: ${error.message}`;
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Apply a simple visual effect to demonstrate image processing
        function applyDemoProcessing() {
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Applying demo processing...';
            log('Starting image processing');
            
            setTimeout(() => {
                try {
                    // Create a canvas to manipulate the image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions to match the image
                    canvas.width = imageDisplay.naturalWidth;
                    canvas.height = imageDisplay.naturalHeight;
                    
                    log('Created processing canvas', {
                        width: canvas.width,
                        height: canvas.height
                    });
                    
                    // Draw the image onto the canvas
                    ctx.drawImage(imageDisplay, 0, 0);
                    
                    // Apply a simple effect (invert colors)
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    log('Processing image data', {
                        pixelCount: data.length / 4
                    });
                    
                    // Invert all colors as a simple demo effect
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];         // Red
                        data[i + 1] = 255 - data[i + 1]; // Green
                        data[i + 2] = 255 - data[i + 2]; // Blue
                        // data[i + 3] is alpha (transparency)
                    }
                    
                    // Put the modified image data back to the canvas
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Update the displayed image with the processed version
                    imageDisplay.src = canvas.toDataURL();
                    
                    // Update information
                    imageInfo.innerHTML += '<br><strong>Status: Processed (colors inverted)</strong>';
                    log('Image processing complete');
                } catch (error) {
                    log('Error applying processing', error.message);
                    console.error('Error applying processing:', error);
                    alert('Error applying processing: ' + error.message);
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            }, 500); // Small delay to allow the loading indicator to display
        }
        
        // Helper function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Clear all images from IndexedDB
        async function clearDatabase() {
            log('Clearing image database...');
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Clearing database...';
            
            try {
                // Clear the database without confirmation
                await clearImageDatabase();
                
                // Clear the current display
                imageDisplay.src = '';
                imageInfo.textContent = 'Database cleared. No images loaded.';
                
                // Clear thumbnails
                thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images found</div>';
                
                // Log success message to debug panel
                log('Database cleared successfully');
                
            } catch (error) {
                log('Error clearing database:', error.message);
                console.error('Error clearing database:', error);
            } finally {
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Clean up resources when page unloads
        window.addEventListener('beforeunload', () => {
            // Revoke all object URLs
            document.querySelectorAll('[data-object-url]').forEach(el => {
                if (el.dataset.objectUrl) {
                    URL.revokeObjectURL(el.dataset.objectUrl);
                }
            });
        });
        
        // Database update tracking
        let lastImageCount = 0;
        let lastDatabaseTimestamp = Date.now();
        let currentImageId = null;
        let currentImageTimestamp = 0;
        const syncStatusIndicator = document.getElementById('syncStatus');

        // Start polling for database changes
        function startDatabasePolling() {
            log('Starting database change detection');
            
            // Store initial state
            getAllImagesMetadata().then(images => {
                lastImageCount = images ? images.length : 0;
                lastDatabaseTimestamp = Date.now();
                log(`Initial database state: ${lastImageCount} images`);
            });
            
            // Set up a separate interval for checking the current image changes more frequently
            const currentImageCheckInterval = setInterval(async () => {
                try {
                    // Only check if we have a current image loaded
                    if (currentImageId) {
                        const currentImageRecord = await getCurrentImage();
                        
                        // Check if current image has changed
                        if (currentImageRecord && currentImageRecord.timestamp > currentImageTimestamp) {
                            // Store new timestamp
                            currentImageTimestamp = currentImageRecord.timestamp;
                            
                            // Reload the current image quietly
                            await loadCurrentImage();
                        }
                    }
                } catch (error) {
                    console.error('Error checking current image updates:', error);
                }
            }, 500); // Check current image every 500ms
            
            // Check for changes in all images every second
            const pollingInterval = setInterval(async () => {
                try {
                    // Quick flash of sync indicator (minimal visibility)
                    syncStatusIndicator.classList.add('active');
                    
                    // Get current database state
                    const allImages = await getAllImagesMetadata();
                    const currentCount = allImages ? allImages.length : 0;
                    
                    // Check if image count changed
                    if (currentCount !== lastImageCount) {
                        // Update our stored count
                        lastImageCount = currentCount;
                        lastDatabaseTimestamp = Date.now();
                        
                        // Refresh thumbnails to reflect changes
                        await loadThumbnails();
                        
                        // If we have no current image but there are images in the database, 
                        // select the first one
                        if ((!imageDisplay.src || imageDisplay.src.endsWith('No image loaded')) && currentCount > 0) {
                            const firstThumbnail = thumbnailsContainer.querySelector('.thumbnail-item');
                            if (firstThumbnail) {
                                const imageId = firstThumbnail.dataset.imageId;
                                if (imageId) {
                                    loadImageById(imageId);
                                }
                            }
                        }
                        
                        // Check if currently displayed image has been deleted
                        if (currentImageId) {
                            const imageStillExists = allImages.some(img => img.id === currentImageId);
                            if (!imageStillExists) {
                                // Reset display
                                imageDisplay.src = '';
                                imageInfo.textContent = 'Please select an image';
                                currentImageId = null;
                                
                                // Try to load the first image if available
                                const firstThumbnail = thumbnailsContainer.querySelector('.thumbnail-item');
                                if (firstThumbnail) {
                                    const imageId = firstThumbnail.dataset.imageId;
                                    if (imageId) {
                                        loadImageById(imageId);
                                    }
                                }
                            }
                        }
                    } else {
                        // Even if the count hasn't changed, check for updates to individual images
                        // This could catch cases where an image was replaced but the count stayed the same
                        const timeSinceLastCheck = Date.now() - lastDatabaseTimestamp;
                        
                        // Only do the more intensive check if enough time has passed (5 seconds)
                        if (timeSinceLastCheck > 5000) {
                            // Check if any image has a newer timestamp than our last update
                            const hasNewerImages = allImages.some(img => img.timestamp > lastDatabaseTimestamp);
                            if (hasNewerImages) {
                                lastDatabaseTimestamp = Date.now();
                                
                                // Refresh thumbnails
                                await loadThumbnails();
                            }
                        }
                    }
                    
                    // Hide sync indicator immediately
                    syncStatusIndicator.classList.remove('active');
                } catch (error) {
                    console.error('Error checking for database updates:', error);
                    syncStatusIndicator.classList.remove('active');
                }
            }, 1000); // Check every second
            
            // Clean up the interval when the page is unloaded
            window.addEventListener('beforeunload', () => {
                clearInterval(pollingInterval);
                clearInterval(currentImageCheckInterval);
            });
        }
    </script>
</body>
</html> 