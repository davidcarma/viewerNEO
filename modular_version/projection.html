<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Projection</title>
    <link rel="stylesheet" href="css/components/thumbnail.css">
    <link rel="stylesheet" href="css/components/thumbnail-panel.css">
    <link rel="stylesheet" href="css/components/thumbnail-arrow-fix.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        header {
            background-color: #111;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }
        h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        .controls {
            padding: 10px 20px;
            background-color: #333;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        button {
            background-color: #444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        button:active {
            background-color: #666;
        }
        .content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            margin-top: 10px; /* Add some spacing between controls and content */
        }
        .image-container {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #imageDisplay {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .status-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
            width: 350px;
        }
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
            display: none;
        }
        .debug-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            max-width: 80%;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            color: #aaffaa;
        }
        
        /* Adjust content when thumbnails are visible */
        .content.with-thumbnails {
            margin-left: 250px;
            transition: margin-left 0.25s ease;
            will-change: margin-left;
            padding-top: 0; /* No need for extra padding since panel is below controls now */
        }
        
        /* Make the thumbnail panel wider for projection page */
        #thumbnail-panel {
            width: 250px !important;
            top: 120px !important; /* Position below the header + controls */
            z-index: 200; /* Ensure it appears above other content */
            height: calc(100vh - 120px) !important; /* Adjust height to account for header and controls */
            position: fixed; /* Ensure fixed positioning */
            left: -250px; /* Start offscreen */
            transition: left 0.25s ease; /* Smooth transition */
            background-color: #333; /* Match app background */
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.4); /* Add shadow for depth */
            overflow-y: auto; /* Allow scrolling */
        }
        
        /* Active state for the panel */
        #thumbnail-panel.active {
            left: 0 !important; /* Slide in from the left */
        }
        
        /* Remove all custom styling for the toggle handle and use the shared CSS */
        #thumbnail-toggle-handle {
            position: fixed !important;
            left: 0 !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            width: 16px !important;
            height: 40px !important;
            background-color: #2c2c2c !important;
            border-radius: 0 4px 4px 0 !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            cursor: pointer !important;
            z-index: 201 !important;
            border: 1px solid #444 !important;
            border-left: none !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2) !important;
            transition: left 0.25s ease, background-color 0.2s ease !important;
            opacity: 0.95 !important;
        }

        #thumbnail-toggle-handle:hover {
            opacity: 1 !important;
            background-color: #3a3a3a !important;
        }

        /* Ensure all pseudo-elements are cleared */
        #thumbnail-toggle-handle::before,
        #thumbnail-toggle-handle::after {
            content: none !important;
            display: none !important;
        }

        /* Position the handle correctly when panel is open */
        #thumbnail-panel.active ~ #thumbnail-toggle-handle {
            left: 250px !important;
        }
        
        /* Create a new chevron arrow with a div */
        #thumbnail-toggle-handle .toggle-arrow {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 6px solid rgba(255, 255, 255, 0.9);
        }

        /* Flip arrow when panel is active */
        #thumbnail-panel.active ~ #thumbnail-toggle-handle .toggle-arrow {
            border-left: none;
            border-right: 6px solid rgba(255, 255, 255, 0.9);
        }
        
        /* Improve thumbnail styling for projection page */
        .thumbnail-item {
            width: 230px;
            margin: 10px auto;
            border-radius: 6px;
            background: #222;
        }
        
        .thumbnail-item img {
            height: 150px;
            object-fit: contain;
            background: #111;
        }
        
        /* Improve thumbnail label styling */
        .thumbnail-item div {
            font-size: 11px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            background: rgba(0,0,0,0.7);
            padding: 6px;
            text-align: left;
        }
        
        /* Style for active thumbnail */
        .thumbnail-item.active {
            border: 2px solid #ff0059;
            box-shadow: 0 0 8px rgba(255,0,89,0.4);
        }
        
        /* Batch header styling */
        .batch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #1a1a1a;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px 0;
            opacity: 1; /* Ensure full visibility */
            visibility: visible; /* Explicitly ensure visibility */
        }
        
        .batch-header .chevron {
            transition: transform 0.2s ease;
        }
        
        .batch-header.collapsed .chevron {
            transform: rotate(-90deg);
        }
        
        .batch-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .batch-title {
            font-size: 13px;
            font-weight: 500;
        }
        
        .batch-count {
            background: rgba(80, 80, 80, 0.5);
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 11px;
            min-width: 16px;
            text-align: center;
        }
        
        .batch-content {
            overflow: hidden;
            max-height: 3000px; /* Arbitrary large value */
            display: block; /* Ensure it's explicitly visible */
            transition: none; /* Disable transition initially */
        }
        
        .batch-content.collapsed {
            max-height: 0;
        }
        
        /* Enable transitions after initial load */
        .transitions-enabled .batch-content {
            transition: max-height 0.3s ease;
        }
        
        .batch-divider {
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
        }
        
        /* Sync status indicator */
        .sync-status {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 5px 10px;
            font-size: 11px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .sync-status.active {
            opacity: 0.6;
        }
        
        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #4CAF50;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Image Projection</h1>
        <div>
            <button id="backToViewer" style="background-color: #4CAF50; border-color: #3d8b40; color: white;">Back to Viewer</button>
        </div>
    </header>
    
    <div class="controls">
        <button id="loadCurrentImage" style="background-color: #2196F3; border-color: #1976D2; color: white;">Load Current Image</button>
        <button id="loadAllImages" style="background-color: #9c27b0; border-color: #7b1fa2; color: white;">Load All Images</button>
        <button id="clear-db-btn" style="background-color: #f44336; border-color: #d32f2f; color: white;">Clear DB</button>
        <button id="applyProcessing" style="background-color: #ff9800; border-color: #f57c00; color: white;">Apply Processing (Demo)</button>
        <button id="showDebug" style="background-color: #795548; border-color: #5d4037; color: white;">Show Debug Info</button>
        <button id="toggle-thumbnails" style="background-color: #00BCD4; border-color: #0097A7; color: white;">Show Thumbnails</button>
    </div>
    
    <div id="thumbnail-panel">
        <div class="thumbnail-header">
            <h3>Images</h3>
            <button id="close-thumbnails" class="icon-btn" style="background-color: #f44336; border-color: #d32f2f; color: white;" aria-label="Close thumbnails">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div id="thumbnails-container"></div>
    </div>
    
    <!-- Thumbnail toggle handle - empty to avoid duplicate content -->
    <div id="thumbnail-toggle-handle" role="button" aria-label="Toggle thumbnail panel" title="Toggle thumbnails">
        <div class="toggle-arrow"></div>
    </div>
    
    <div class="content">
        <div class="image-container">
            <img id="imageDisplay" alt="No image loaded">
        </div>
        
        <div class="status-container">
            <div id="imageInfo">No image loaded</div>
        </div>
        
        <div id="debugLog" class="debug-log" style="display: none;"></div>
        
        <div class="loading">Loading...</div>
        
        <div class="sync-status" id="syncStatus">
            <div class="sync-indicator"></div>
            <span>Syncing with database...</span>
        </div>
    </div>
    
    <script type="module">
        // Import modules and utilities from the modular application
        import { getCurrentImage, createImageFromRecord } from './modular_version/src/services/db/currentImageStore.js';
        import { getAllImagesMetadata, getImageFromDb, clearImageDatabase } from './modular_version/src/services/db/imageStore.js';
        
        /**
         * BIDIRECTIONAL COMMUNICATION OVERVIEW
         * 
         * This page now communicates bidirectionally with the main index.html viewer using IndexedDB:
         * 
         * 1. RECEIVING CHANGES (index.html → projection.html):
         *    - The database monitoring system (startDbMonitoring) polls the database for changes
         *    - When changes are detected (new current image, added/deleted images), this page updates
         *    - Changes from the main viewer are automatically reflected here
         * 
         * 2. SENDING CHANGES (projection.html → index.html):
         *    - When selecting an image in this page, setCurrentImageInDatabase updates the current_image
         *    - The main viewer will detect this change through its own monitoring system
         *    - This creates a two-way sync where either page can control what's displayed
         * 
         * The monitoring systems in both pages ensure changes are reflected almost instantly
         * without requiring page refreshes or manual synchronization.
         */
        
        // Debug logging
        const debugPanel = document.getElementById('debug-panel');
        function log(message, data) {
            console.log(message, data);
            const logEntry = document.createElement('div');
            logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
            if (data) {
                try {
                    logEntry.textContent += `: ${JSON.stringify(data)}`;
                } catch (e) {
                    logEntry.textContent += `: ${data}`;
                }
            }
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            log('Projection page loaded');
            
            // Set up thumbnail panel toggle functionality
            toggleThumbnailsBtn.addEventListener('click', toggleThumbnailPanel);
            closeThumbnailsBtn.addEventListener('click', toggleThumbnailPanel);
            toggleHandle.addEventListener('click', toggleThumbnailPanel);
            
            // Make sure toggle handle has the correct initial state
            if (toggleHandle) {
                // Clear any existing content that might cause styling issues
                toggleHandle.innerHTML = '';
                
                // Create a proper toggle arrow
                const toggleArrow = document.createElement('div');
                toggleArrow.className = 'toggle-arrow';
                toggleHandle.appendChild(toggleArrow);
            }
            
            // Load thumbnails
            await loadThumbnails();
            
            // Show thumbnail panel by default
            toggleThumbnailPanel();
            
            // Try to load the current image automatically on page load
            setTimeout(async () => {
                const imageLoaded = await loadCurrentImage();
                if (!imageLoaded) {
                    // If no current image exists, try to load the first image from the first batch
                    // (which will now exclude the current image due to our loadThumbnails modification)
                    const firstThumbnail = thumbnailsContainer.querySelector('.thumbnail-item');
                    if (firstThumbnail) {
                        const imageId = firstThumbnail.dataset.imageId;
                        if (imageId) {
                            loadImageById(imageId);
                        }
                    }
                }
                
                // Enable transitions after page content has loaded
                setTimeout(() => {
                    document.body.classList.add('transitions-enabled');
                    log('Transitions enabled');
                }, 500);
            }, 100);
            
            // Start database polling for updates
            startDatabasePolling();
            
            // Initialize database monitoring
            log('Starting database change monitoring');
            startDbMonitoring();
            
            // Stop monitoring when the window unloads
            window.addEventListener('unload', stopDbMonitoring);
        });
        
        // Toggle thumbnail panel
        function toggleThumbnailPanel() {
            thumbnailPanel.classList.toggle('active');
            contentElement.classList.toggle('with-thumbnails');
            
            // Clear any existing content and ensure proper styling
            const toggleArrow = toggleHandle.querySelector('.toggle-arrow');
            if (!toggleArrow) {
                const newArrow = document.createElement('div');
                newArrow.className = 'toggle-arrow';
                toggleHandle.innerHTML = '';
                toggleHandle.appendChild(newArrow);
            }
            
            if (thumbnailPanel.classList.contains('active')) {
                toggleThumbnailsBtn.textContent = 'Hide Thumbnails';
            } else {
                toggleThumbnailsBtn.textContent = 'Show Thumbnails';
            }
        }
        
        // Load thumbnails from IndexedDB
        async function loadThumbnails() {
            try {
                log('Loading thumbnails from IndexedDB');
                
                // Store collapsed states before clearing
                const collapsedBatchStates = new Map();
                document.querySelectorAll('.batch-header').forEach(header => {
                    const batchTitle = header.querySelector('.batch-title')?.textContent;
                    if (batchTitle) {
                        collapsedBatchStates.set(batchTitle, header.classList.contains('collapsed'));
                    }
                });
                
                // Clear existing thumbnails
                thumbnailsContainer.innerHTML = '';
                
                // Get all images from IndexedDB
                const allImages = await getAllImagesMetadata();
                
                if (!allImages || allImages.length === 0) {
                    log('No images found in IndexedDB');
                    thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images found</div>';
                    return;
                }
                
                log(`Found ${allImages.length} images in IndexedDB`);
                
                // Filter out the special "current_image" entry to avoid duplication
                // since it's already displayed in the main view
                const filteredImages = allImages.filter(metadata => metadata.id !== CURRENT_IMAGE_KEY);
                
                if (filteredImages.length === 0) {
                    thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No additional images available</div>';
                    return;
                }
                
                // Group images by batch ID
                const batchMap = new Map();
                
                filteredImages.forEach(metadata => {
                    const batchId = metadata.batchId || 'default';
                    
                    if (!batchMap.has(batchId)) {
                        batchMap.set(batchId, []);
                    }
                    
                    batchMap.get(batchId).push(metadata);
                });
                
                // Create a batch element for each batch
                for (const [batchId, imagesList] of batchMap.entries()) {
                    // Sort images by timestamp
                    imagesList.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Create batch header
                    const batchHeader = document.createElement('div');
                    batchHeader.className = 'batch-header';
                    
                    // Ensure immediate visibility with inline styles
                    batchHeader.style.display = 'flex';
                    batchHeader.style.visibility = 'visible';
                    batchHeader.style.opacity = '1';
                    
                    // Create left side container for title and count
                    const leftSide = document.createElement('div');
                    leftSide.className = 'batch-info';
                    
                    // Create title
                    const title = document.createElement('span');
                    title.className = 'batch-title';
                    const batchTitle = `Batch ${batchMap.size > 1 ? Array.from(batchMap.keys()).indexOf(batchId) + 1 : ''}`;
                    title.textContent = batchTitle;
                    leftSide.appendChild(title);
                    
                    // Add count badge
                    const count = document.createElement('span');
                    count.className = 'batch-count';
                    count.textContent = imagesList.length;
                    leftSide.appendChild(count);
                    
                    batchHeader.appendChild(leftSide);
                    
                    // Add chevron icon for expand/collapse
                    const chevron = document.createElement('span');
                    chevron.className = 'chevron';
                    chevron.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>';
                    batchHeader.appendChild(chevron);
                    
                    // Create batch content
                    const batchContent = document.createElement('div');
                    batchContent.className = 'batch-content';
                    
                    // Create reference between header and content elements
                    batchHeader.dataset.contentId = `batch-content-${batchId}`;
                    batchContent.id = `batch-content-${batchId}`;
                    
                    // Only apply collapsed state if explicitly found in the stored states
                    // Otherwise, default to expanded (not collapsed)
                    const wasCollapsed = collapsedBatchStates.has(batchTitle) && collapsedBatchStates.get(batchTitle) === true;
                    if (wasCollapsed) {
                        batchHeader.classList.add('collapsed');
                        batchContent.classList.add('collapsed');
                    }
                    
                    // Add toggle functionality
                    batchHeader.addEventListener('click', (event) => {
                        // Toggle collapsed class on this specific header
                        batchHeader.classList.toggle('collapsed');
                        
                        // Toggle collapsed class on the paired batch content using the reference
                        const contentId = batchHeader.dataset.contentId;
                        const content = document.getElementById(contentId);
                        if (content) {
                            content.classList.toggle('collapsed');
                        }
                        
                        // Log toggle action for debugging
                        log('Batch header toggled', {
                            batchTitle,
                            isCollapsed: batchHeader.classList.contains('collapsed'),
                            contentId
                        });
                        
                        // Prevent event bubbling
                        event.stopPropagation();
                    });
                    
                    thumbnailsContainer.appendChild(batchHeader);
                    
                    // Create thumbnails for each image
                    for (const imageMetadata of imagesList) {
                        if (!imageMetadata.hasBlob) continue;
                        
                        const thumbnailItem = document.createElement('div');
                        thumbnailItem.className = 'thumbnail-item';
                        thumbnailItem.dataset.imageId = imageMetadata.id;
                        
                        const imgEl = document.createElement('img');
                        imgEl.alt = imageMetadata.filename;
                        imgEl.loading = 'lazy';
                        
                        // Use placeholder initially
                        const placeholderSrc = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiMxMTExMTEiLz48cGF0aCBkPSJNMzUgMjVINjVDNjguMyAyNSA3MSAyNy43IDcxIDMxVjY5QzcxIDcyLjMgNjguMyA3NSA2NSA3NUgzNUMzMS43IDc1IDI5IDcyLjMgMjkgNjlWMzFDMjkgMjcuNyAzMS43IDI1IDM1IDI1WiIgc3Ryb2tlPSIjNTU1IiBzdHJva2Utd2lkdGg9IjIiLz48Y2lyY2xlIGN4PSI0MCIgY3k9IjQwIiByPSI1IiBmaWxsPSIjNTU1Ii8+PHBhdGggZD0iTTMwIDYwTDQwIDUwTDUwIDYwTDYwIDUwTDcwIDYwVjcwSDMwVjYwWiIgZmlsbD0iIzU1NSIvPjwvc3ZnPg==';
                        imgEl.src = placeholderSrc;
                        
                        thumbnailItem.appendChild(imgEl);
                        
                        // Create a more detailed label with filename and size
                        const label = document.createElement('div');
                        let labelText = imageMetadata.filename || 'Unnamed image';
                        
                        // Add file size if available
                        if (imageMetadata.blobSize) {
                            labelText += ` (${formatFileSize(imageMetadata.blobSize)})`;
                        }
                        
                        // Add dimensions if available
                        if (imageMetadata.dimensions) {
                            labelText += `<br>${imageMetadata.dimensions.width || '?'} × ${imageMetadata.dimensions.height || '?'} px`;
                        }
                        
                        label.innerHTML = labelText;
                        thumbnailItem.appendChild(label);
                        
                        // Add click event to load the image
                        thumbnailItem.addEventListener('click', () => loadImageById(imageMetadata.id));
                        
                        batchContent.appendChild(thumbnailItem);
                        
                        // Load the actual thumbnail asynchronously
                        loadThumbnailImage(imageMetadata.id, imgEl);
                    }
                    
                    thumbnailsContainer.appendChild(batchContent);
                    
                    // Add divider after each batch except the last one
                    if (Array.from(batchMap.keys()).indexOf(batchId) < batchMap.size - 1) {
                        const divider = document.createElement('div');
                        divider.className = 'batch-divider';
                        thumbnailsContainer.appendChild(divider);
                    }
                }
                
                // Wait a moment for DOM to update, then ensure batch headers are visible
                setTimeout(() => {
                    document.querySelectorAll('.batch-header').forEach(header => {
                        // Ensure batch headers are properly styled
                        header.style.visibility = 'visible';
                        header.style.display = 'flex';
                        header.style.opacity = '1';
                    });
                    log('Batch headers refreshed and made visible');
                }, 50);
                
            } catch (error) {
                log('Error loading thumbnails', error.message);
                console.error('Error loading thumbnails:', error);
                thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">Error loading thumbnails</div>';
            }
        }
        
        // Load thumbnail image from database
        async function loadThumbnailImage(imageId, imgElement) {
            try {
                const imageRecord = await getImageFromDb(imageId);
                if (imageRecord && imageRecord.imageBlob) {
                    const objectUrl = URL.createObjectURL(imageRecord.imageBlob);
                    imgElement.src = objectUrl;
                    imgElement.dataset.objectUrl = objectUrl;
                }
            } catch (error) {
                console.error(`Error loading thumbnail for image ${imageId}:`, error);
            }
        }
        
        // Load image by ID from IndexedDB
        async function loadImageById(imageId) {
            if (!imageId) {
                log('No image ID provided');
                return;
            }
            
            log(`Loading image ${imageId} from IndexedDB`);
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Loading image...';
            
            try {
                // Get the image from IndexedDB
                const imageRecord = await getImageFromDb(imageId);
                
                if (!imageRecord) {
                    log(`Image ${imageId} not found in IndexedDB`);
                    imageInfo.textContent = `Error: Image with ID ${imageId} not found.`;
                    loadingIndicator.style.display = 'none';
                    return;
                }
                
                // Store current image ID for tracking
                currentImageId = imageId;
                currentImageRecord = imageRecord;
                
                // Create an image element from the blob
                const img = await createImageFromRecord(imageRecord);
                
                // Display the image
                imageDisplay.src = img.src;
                
                // Update image info
                imageInfo.innerHTML = `
                    <strong>Image loaded successfully</strong><br>
                    ID: ${imageRecord.id}<br>
                    Filename: ${imageRecord.filename}<br>
                    Size: ${imageRecord.dimensions.width} x ${imageRecord.dimensions.height} px<br>
                    File Type: ${imageRecord.fileType || 'Unknown'}<br>
                    File Size: ${imageRecord.imageBlob.size ? formatFileSize(imageRecord.imageBlob.size) : 'Unknown'}<br>
                    Last Modified: ${new Date(imageRecord.timestamp).toLocaleString()}
                `;
                
                // Update the main viewer with our selection
                if (imageId !== CURRENT_IMAGE_KEY) {
                    await setCurrentImageInDatabase(imageRecord);
                }
                
                // Highlight the selected thumbnail
                const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                thumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('active');
                    if (thumbnail.dataset.imageId === imageId) {
                        thumbnail.classList.add('active');
                        // Scroll to the selected thumbnail
                        thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
                
            } catch (error) {
                log('Error loading image:', error.message);
                console.error('Error loading image:', error);
                imageInfo.textContent = `Error loading image: ${error.message}`;
                loadingIndicator.style.display = 'none';
            }
        }
        
        /**
         * Set the current image in the database for cross-page access
         * This function updates the current_image record to point to the selected image
         */
        async function setCurrentImageInDatabase(imageRecord) {
            if (!imageRecord || !imageRecord.imageBlob) {
                log('Cannot set current image: invalid record or missing blob');
                return false;
            }
            
            try {
                log('Setting current image in database for main viewer', {
                    id: imageRecord.id,
                    filename: imageRecord.filename
                });
                
                // Create a modified copy of the record with current image flag
                const currentImageRecord = {
                    ...imageRecord,
                    id: CURRENT_IMAGE_KEY,  // Use the special key
                    isCurrent: true,
                    timestamp: Date.now(),  // Update timestamp to trigger detection
                    originalId: imageRecord.id  // Store the original ID for reference
                };
                
                // Save to database
                const { saveImageToDb } = await import('./modular_version/src/services/db/imageStore.js');
                const id = await saveImageToDb(null, null, currentImageRecord);
                
                log('Current image set successfully in database', {
                    id,
                    filename: currentImageRecord.filename
                });
                
                return true;
            } catch (error) {
                log('Error setting current image in database:', error.message);
                console.error('Error setting current image in database:', error);
                return false;
            }
        }
        
        // Set up button handlers
        loadButton.addEventListener('click', loadCurrentImage);
        document.getElementById('loadAllImages').addEventListener('click', loadAllImagesFromDb);
        document.getElementById('clear-db-btn').addEventListener('click', clearDatabase);
        backButton.addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        
        // Toggle debug info
        showDebugButton.addEventListener('click', () => {
            if (debugLog.style.display === 'none') {
                debugLog.style.display = 'block';
                showDebugButton.textContent = 'Hide Debug Info';
            } else {
                debugLog.style.display = 'none';
                showDebugButton.textContent = 'Show Debug Info';
            }
        });
        
        // Apply a simple visual processing effect as a demo
        applyProcessingButton.addEventListener('click', () => {
            if (!imageDisplay.src || imageDisplay.src.endsWith('No image loaded')) {
                alert('Please load an image first');
                return;
            }
            
            applyDemoProcessing();
        });
        
        // Load the current image from IndexedDB
        async function loadCurrentImage() {
            try {
                // Show loading indicator
                loadingIndicator.style.display = 'flex';
                loadingIndicator.textContent = 'Loading image from IndexedDB...';
                
                log('Requesting image from IndexedDB');
                
                // Get the current image from IndexedDB
                const imageRecord = await getCurrentImage();
                
                if (!imageRecord) {
                    log('No image record found in IndexedDB');
                    imageInfo.textContent = 'No image found in storage. Please load an image in the main viewer first.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                log('Retrieved image record', {
                    id: imageRecord.id,
                    filename: imageRecord.filename,
                    hasBlobData: !!imageRecord.imageBlob,
                    blobSize: imageRecord.imageBlob?.size,
                    dimensions: imageRecord.dimensions
                });
                
                // Store the current image ID for sync detection
                currentImageId = imageRecord.id;
                
                if (!imageRecord.imageBlob) {
                    log('Error: Image record has no blob data');
                    imageInfo.textContent = 'Error: Image record exists but contains no image data.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                // Highlight the current image in thumbnails if it exists
                const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                thumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('active');
                    
                    // After our filtering, the current image shouldn't exist in thumbnails
                    // This check remains only for backward compatibility
                    if (thumbnail.dataset.imageId === imageRecord.id) {
                        thumbnail.classList.add('active');
                        
                        // Scroll to the selected thumbnail
                        thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                // Create an image element from the blob
                log('Creating image element from blob', {
                    type: imageRecord.imageBlob.type,
                    size: imageRecord.imageBlob.size
                });
                
                const img = await createImageFromRecord(imageRecord);
                log('Image created from blob', {
                    width: img.width,
                    height: img.height,
                    complete: img.complete
                });
                
                // Display the image
                const objectUrl = img.src;
                imageDisplay.src = objectUrl;
                
                // Wait for the image to load
                imageDisplay.onload = () => {
                    log('Image loaded and displayed', {
                        naturalWidth: imageDisplay.naturalWidth,
                        naturalHeight: imageDisplay.naturalHeight
                    });
                    
                    // Update image info
                    imageInfo.innerHTML = `
                        <strong>Image loaded successfully</strong><br>
                        Filename: ${imageRecord.filename}<br>
                        Size: ${imageRecord.dimensions.width} x ${imageRecord.dimensions.height} px<br>
                        File Type: ${imageRecord.fileType || 'Unknown'}<br>
                        File Size: ${imageRecord.imageBlob.size ? formatFileSize(imageRecord.imageBlob.size) : 'Unknown'}<br>
                        Last Modified: ${new Date(imageRecord.timestamp).toLocaleString()}
                    `;
                    
                    loadingIndicator.style.display = 'none';
                };
                
                imageDisplay.onerror = (e) => {
                    log('Error displaying image', e);
                    imageInfo.textContent = `Error displaying image. See debug info for details.`;
                    loadingIndicator.style.display = 'none';
                    return false;
                };
                
            } catch (error) {
                log('Error loading image from IndexedDB', error.message);
                console.error('Error loading image from IndexedDB:', error);
                imageInfo.textContent = `Error loading image: ${error.message}`;
                loadingIndicator.style.display = 'none';
                return false;
            }
        }
        
        // Load all images from IndexedDB
        async function loadAllImagesFromDb() {
            log('Loading all images from database');
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Loading all images...';
            
            try {
                // Get all images metadata
                const allImages = await getAllImagesMetadata();
                
                if (!allImages || allImages.length === 0) {
                    log('No images found in database');
                    imageInfo.textContent = 'No images found in database.';
                    loadingIndicator.style.display = 'none';
                    return;
                }
                
                log(`Found ${allImages.length} images in database`);
                
                // Reset thumbnails
                await loadThumbnails();
                
                // Select the first image with a blob, excluding the current image
                const imagesWithBlobs = allImages
                    .filter(img => img.hasBlob && img.id !== CURRENT_IMAGE_KEY);
                
                if (imagesWithBlobs.length > 0) {
                    loadImageById(imagesWithBlobs[0].id);
                } else {
                    log('No images with blobs found');
                    imageInfo.textContent = 'No valid images found in database.';
                    loadingIndicator.style.display = 'none';
                }
            } catch (error) {
                log('Error loading all images', error.message);
                console.error('Error loading all images:', error);
                imageInfo.textContent = `Error loading images: ${error.message}`;
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Apply a simple visual effect to demonstrate image processing
        function applyDemoProcessing() {
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Applying demo processing...';
            log('Starting image processing');
            
            setTimeout(() => {
                try {
                    // Create a canvas to manipulate the image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions to match the image
                    canvas.width = imageDisplay.naturalWidth;
                    canvas.height = imageDisplay.naturalHeight;
                    
                    log('Created processing canvas', {
                        width: canvas.width,
                        height: canvas.height
                    });
                    
                    // Draw the image onto the canvas
                    ctx.drawImage(imageDisplay, 0, 0);
                    
                    // Apply a simple effect (invert colors)
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    log('Processing image data', {
                        pixelCount: data.length / 4
                    });
                    
                    // Invert all colors as a simple demo effect
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];         // Red
                        data[i + 1] = 255 - data[i + 1]; // Green
                        data[i + 2] = 255 - data[i + 2]; // Blue
                        // data[i + 3] is alpha (transparency)
                    }
                    
                    // Put the modified image data back to the canvas
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Update the displayed image with the processed version
                    imageDisplay.src = canvas.toDataURL();
                    
                    // Update information
                    imageInfo.innerHTML += '<br><strong>Status: Processed (colors inverted)</strong>';
                    log('Image processing complete');
                } catch (error) {
                    log('Error applying processing', error.message);
                    console.error('Error applying processing:', error);
                    alert('Error applying processing: ' + error.message);
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            }, 500); // Small delay to allow the loading indicator to display
        }
        
        // Helper function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Clear all images from IndexedDB
        async function clearDatabase() {
            log('Clearing image database...');
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Clearing database...';
            
            try {
                // Clear the database without confirmation
                await clearImageDatabase();
                
                // Clear the current display
                imageDisplay.src = '';
                imageInfo.textContent = 'Database cleared. No images loaded.';
                
                // Clear thumbnails
                thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images found</div>';
                
                // Log success message to debug panel
                log('Database cleared successfully');
                
            } catch (error) {
                log('Error clearing database:', error.message);
                console.error('Error clearing database:', error);
            } finally {
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Clean up resources when page unloads
        window.addEventListener('beforeunload', () => {
            // Revoke all object URLs
            document.querySelectorAll('[data-object-url]').forEach(el => {
                if (el.dataset.objectUrl) {
                    URL.revokeObjectURL(el.dataset.objectUrl);
                }
            });
        });
        
        let lastImageCount = 0;
        let lastDatabaseTimestamp = 0;
        let currentImageId = null;
        let currentImageTimestamp = 0;
        const syncStatusIndicator = document.getElementById('syncStatus');

        // Enhanced database monitoring system (replaces old polling mechanism)
        function startDatabasePolling() {
            log('Starting enhanced database monitoring');
            
            // Use our new monitoring system
            return startDbMonitoring();
        }
        
        // Constants for database monitoring  
        const CHECK_INTERVAL = 2000; // Check every 2 seconds
        
        // Variables for DB monitoring
        let isMonitoring = false;
        let monitorInterval = null;
        let lastCurrentImageTimestamp = 0;
        let lastKnownImageCount = 0;
        
        // Initialize monitoring
        function startDbMonitoring() {
            if (isMonitoring) return;
            
            log('Starting IndexedDB monitoring');
            isMonitoring = true;
            
            // Initialize timestamps from current state
            const imageRecord = getCurrentImageRecord();
            lastCurrentImageTimestamp = imageRecord?.timestamp || 0;
            
            // Initialize image count
            getAllImagesMetadata().then(images => {
                lastKnownImageCount = images ? images.filter(img => 
                    img.id !== CURRENT_IMAGE_KEY && img.hasBlob
                ).length : 0;
                
                log(`Initial database state: ${lastKnownImageCount} images`);
            });
            
            // Show sync indicator when checking
            function updateSyncIndicator(isChecking) {
                if (isChecking) {
                    syncStatusIndicator.classList.add('active');
                } else {
                    syncStatusIndicator.classList.remove('active');
                }
            }
            
            // Set up polling interval
            monitorInterval = setInterval(async () => {
                updateSyncIndicator(true);
                await checkForDbChanges();
                updateSyncIndicator(false);
            }, CHECK_INTERVAL);
            
            // Return a cleanup function
            return () => stopDbMonitoring();
        }
        
        // Stop monitoring the database
        function stopDbMonitoring() {
            if (!isMonitoring) return;
            
            log('Stopping IndexedDB monitoring');
            isMonitoring = false;
            
            if (monitorInterval) {
                clearInterval(monitorInterval);
                monitorInterval = null;
            }
        }
        
        // Store the current image record
        let currentImageRecord = null;
        
        function getCurrentImageRecord() {
            return currentImageRecord;
        }
        
        // Check for changes in the database
        async function checkForDbChanges() {
            try {
                // Skip check if we're in the middle of loading or processing
                if (loadingIndicator.style.display === 'flex') {
                    log('Skipping DB check while page is loading/processing');
                    return;
                }
                
                // Get the current image record
                const newImageRecord = await getCurrentImage();
                const currentTimestamp = newImageRecord?.timestamp || 0;
                
                // Check if current image has changed
                const currentImageChanged = currentTimestamp > lastCurrentImageTimestamp;
                
                // Get all image metadata
                const allMetadata = await getAllImagesMetadata();
                
                // Count regular images (exclude current image)
                const newImageCount = allMetadata.filter(img => 
                    img.id !== CURRENT_IMAGE_KEY && 
                    img.hasBlob
                ).length;
                
                const imageCountChanged = newImageCount !== lastKnownImageCount;
                lastKnownImageCount = newImageCount;
                
                // Also check if currently displayed image was deleted
                let currentImageDeleted = false;
                if (currentImageId && currentImageId !== CURRENT_IMAGE_KEY) {
                    const imageStillExists = allMetadata.some(img => img.id === currentImageId);
                    if (!imageStillExists) {
                        currentImageDeleted = true;
                    }
                }
                
                // Only process if something has changed
                if (currentImageChanged || imageCountChanged || currentImageDeleted) {
                    log('Detected changes in IndexedDB:', {
                        currentImageChanged,
                        imageCountChanged,
                        currentImageDeleted,
                        oldTimestamp: lastCurrentImageTimestamp,
                        newTimestamp: currentTimestamp,
                        oldCount: lastKnownImageCount,
                        newCount: newImageCount
                    });
                    
                    // Update last known timestamp if current image changed
                    if (currentImageChanged) {
                        lastCurrentImageTimestamp = currentTimestamp;
                        currentImageRecord = newImageRecord;
                        
                        // Reload current image since it changed
                        log('Current image changed in database, reloading...');
                        await loadCurrentImage();
                    }
                    
                    // If image count changed or an image was deleted
                    if (imageCountChanged || currentImageDeleted) {
                        // Reload thumbnails since available images changed
                        log('Available images changed in database, updating thumbnails...');
                        await loadThumbnails();
                        
                        // If current image was deleted, load the first available image
                        if (currentImageDeleted) {
                            log('Current image was deleted, loading first available image...');
                            
                            // Reset display
                            imageDisplay.src = '';
                            imageInfo.textContent = 'Please select an image';
                            currentImageId = null;
                            
                            // Try to load the first image if available
                            const firstThumbnail = thumbnailsContainer.querySelector('.thumbnail-item');
                            if (firstThumbnail) {
                                const imageId = firstThumbnail.dataset.imageId;
                                if (imageId) {
                                    loadImageById(imageId);
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                log('Error checking for database changes:', error.message);
                console.error('Error checking for database changes:', error);
            }
        }
    </script>
</body>
</html> 