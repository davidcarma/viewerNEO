<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Projection</title>
    <!-- Import the same CSS files as the main viewer for consistency -->
    <link rel="stylesheet" href="css/legacy.css">
    <link rel="stylesheet" href="css/components/thumbnail.css">
    <link rel="stylesheet" href="css/components/thumbnail-panel.css">
    <link rel="stylesheet" href="css/components/thumbnail-arrow-fix.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        header {
            background-color: #111;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }
        h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        .controls {
            padding: 10px 20px;
            background-color: #333;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        button {
            background-color: #444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        button:active {
            background-color: #666;
        }
        .content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            margin-top: 10px; /* Add some spacing between controls and content */
        }
        .image-container {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #imageDisplay {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: none; /* Hide the image since we're using canvas */
        }
        #canvas {
            max-width: 100%;
            max-height: 100%;
            background-color: #222;
            position: relative; /* Prevent position issues */
            z-index: 5; /* Ensure canvas is above other elements */
        }
        
        /* Container styles to match main viewer */
        #container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px); /* Account for header and controls */
            width: 100%;
            position: relative;
            transition: transform 0.25s ease;
            margin-top: 10px;
        }
        
        /* Match the behavior of index.html */
        #container.with-thumbnails {
            transform: translateX(160px);
        }
        
        /* Ensure thumbnail panel appears below header and controls */
        body #thumbnail-panel {
            top: 120px !important;
            height: calc(100vh - 120px) !important;
            z-index: 100;
        }
        
        /* Ensure toggle handle is positioned correctly */
        body #thumbnail-toggle-handle {
            top: 50% !important;
            margin-top: 60px !important; /* Shift down by half of the header+controls height */
        }
        
        /* Hide delete buttons on read-only projection page */
        .thumbnail-delete-btn,
        .thumbnail-remove-btn,
        .batch-delete-btn {
            display: none !important;
        }
        
        .status-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
            width: 350px;
        }
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
            display: none;
        }
        .debug-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            max-width: 80%;
            max-height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            color: #aaffaa;
        }
        
        /* Removed content.with-thumbnails as we now use container.with-thumbnails */
    </style>
</head>
<body>
    <header>
        <h1>Image Projection</h1>
        <div style="display: flex; align-items: center; gap: 10px;">
            <div class="sync-status" id="syncStatus" style="position: relative; top: 0; right: 0; opacity: 0.6;">
                <div class="sync-indicator"></div>
                <span>Syncing with database...</span>
            </div>
            <button id="backToViewer" style="background-color: #4CAF50; border-color: #3d8b40; color: white;">Back to Viewer</button>
        </div>
    </header>
        
        <div class="controls">
            <button id="loadCurrentImage" style="background-color: #2196F3; border-color: #1976D2; color: white;">Load Current Image</button>
            <button id="loadAllImages" style="background-color: #9c27b0; border-color: #7b1fa2; color: white;">Load All Images</button>
            <button id="clear-db-btn" style="background-color: #f44336; border-color: #d32f2f; color: white;">Clear DB</button>
            <button id="applyProcessing" style="background-color: #ff9800; border-color: #f57c00; color: white;">Apply Processing (Demo)</button>
            <button id="showDebug" style="background-color: #795548; border-color: #5d4037; color: white;">Show Debug Info</button>
            <button id="toggle-thumbnails" style="background-color: #00BCD4; border-color: #0097A7; color: white;">Show Thumbnails</button>
        </div>
        
        <div id="thumbnail-panel" style="top: 120px; height: calc(100vh - 120px);">
            <div class="thumbnail-header">
                <h3>Images</h3>
                <button id="close-thumbnails" class="icon-btn" style="background-color: #f44336; border-color: #d32f2f; color: white;" aria-label="Close thumbnails">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div id="thumbnails-container"></div>
        </div>
        
        <!-- Thumbnail toggle handle -->
        <div id="thumbnail-toggle-handle" role="button" aria-label="Toggle thumbnail panel" title="Toggle thumbnails"></div>
        
        <div id="container">
        <div class="content">
                    <div class="image-container">
            <canvas id="canvas"></canvas>
            <img id="imageDisplay" alt="No image loaded" style="display: none;">
        </div>
            
            <div class="status-container">
                <div id="imageInfo">No image loaded</div>
            </div>
            
                    <div id="debugLog" class="debug-log" style="display: none;"></div>
        
        <div class="loading">Loading...</div>
    </div>
    </div>
    
    <script type="module">
        // Import modules and utilities from the modular application
        import { getCurrentImage, createImageFromRecord } from './src/services/db/currentImageStore.js';
        import { getAllImagesMetadata, getImageFromDb, clearImageDatabase } from './src/services/db/imageStore.js';
        import { registerChangeObserver, unregisterChangeObserver, startDbMonitoring } from './src/services/db/dbMonitor.js';
        
        // Helper function to size and position canvas properly
        async function sizeCanvasToImage(img, imageRecord) {
            const { getCanvas } = await import('./src/ui/canvas/canvasContext.js');
            const canvas = getCanvas();
            if (!canvas) return;
            
            // Make sure we have valid dimensions
            const width = img.naturalWidth || imageRecord.dimensions.width || 640;
            const height = img.naturalHeight || imageRecord.dimensions.height || 480;
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Make sure the canvas is visible and properly sized
            canvas.style.maxWidth = '100%';
            canvas.style.maxHeight = '100%';
            canvas.style.display = 'block';
            canvas.style.margin = 'auto';
        }
        
        /**
         * BIDIRECTIONAL COMMUNICATION OVERVIEW
         * 
         * This page now communicates bidirectionally with the main index.html viewer using IndexedDB:
         * 
         * 1. RECEIVING CHANGES (index.html → projection.html):
         *    - The database monitoring system (startDbMonitoring) polls the database for changes
         *    - When changes are detected (new current image, added/deleted images), this page updates
         *    - Changes from the main viewer are automatically reflected here
         * 
         * 2. SENDING CHANGES (projection.html → index.html):
         *    - When selecting an image in this page, setCurrentImageInDatabase updates the current_image
         *    - The main viewer will detect this change through its own monitoring system
         *    - This creates a two-way sync where either page can control what's displayed
         * 
         * The monitoring systems in both pages ensure changes are reflected almost instantly
         * without requiring page refreshes or manual synchronization.
         */
        
        // Debug logging
        const debugPanel = document.getElementById('debug-panel');
        function log(message, data) {
            console.log(message, data);
            const logEntry = document.createElement('div');
            logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
            if (data) {
                try {
                    logEntry.textContent += `: ${JSON.stringify(data)}`;
                } catch (e) {
                    logEntry.textContent += `: ${data}`;
                }
            }
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
        
        // Get references to DOM elements - making them globally accessible
        const loadingIndicator = document.querySelector('.loading');
        const imageDisplay = document.getElementById('imageDisplay');
        const imageInfo = document.getElementById('imageInfo');
        const debugLog = document.getElementById('debugLog');
        const loadButton = document.getElementById('loadCurrentImage');
        const applyProcessingButton = document.getElementById('applyProcessing');
        const backButton = document.getElementById('backToViewer');
        const showDebugButton = document.getElementById('showDebug');
        const thumbnailPanel = document.getElementById('thumbnail-panel');
        const thumbnailsContainer = document.getElementById('thumbnails-container');
        const toggleThumbnailsBtn = document.getElementById('toggle-thumbnails');
        const toggleHandle = document.getElementById('thumbnail-toggle-handle');
        const closeThumbnailsBtn = document.getElementById('close-thumbnails');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            log('Projection page loaded');
            
            // Set up thumbnail panel toggle functionality
            toggleThumbnailsBtn.addEventListener('click', toggleThumbnailPanel);
            closeThumbnailsBtn.addEventListener('click', toggleThumbnailPanel);
            toggleHandle.addEventListener('click', toggleThumbnailPanel);
            
                // Initialize database monitoring first
    log('Starting database change monitoring');
    initializeMonitoring();
            
            // Load thumbnails to show available images
            await loadThumbnails();
            
            // Show thumbnail panel by default
            toggleThumbnailPanel();
            
            // Try to load images in a sequence that matches index.html:
            // 1. First try to load current image (from the main viewer)
            // 2. If that fails, try to load the first image from the first batch
            const loadingSequence = async () => {
                // Start with the current image from the main viewer
                const currentImageLoaded = await loadCurrentImage();
                
                if (!currentImageLoaded) {
                    log('No current image found, loading first available image...');
                    
                    // If current image loading failed, get all images and find first in batch
                    const allImages = await getAllImagesMetadata();
                    
                    if (!allImages || allImages.length === 0) {
                        log('No images found in database');
                        imageInfo.textContent = 'No images found in database. Please load images in the main viewer first.';
                        return;
                    }
                    
                    // Group images by batch ID to match index.html's structure
                    const batchMap = new Map();
                    const processedFilenames = new Set();
                    
                    // Process images (skip current_image and duplicates)
                    for (const metadata of allImages) {
                        if (metadata.id === CURRENT_IMAGE_KEY || !metadata.hasBlob) continue;
                        
                        const batchId = metadata.batchId || 'default';
                        const filename = metadata.filename;
                        
                        if (processedFilenames.has(filename)) continue;
                        processedFilenames.add(filename);
                        
                        if (!batchMap.has(batchId)) {
                            batchMap.set(batchId, []);
                        }
                        
                        batchMap.get(batchId).push(metadata);
                    }
                    
                    // Find first image in first batch, exactly as index.html does
                    if (batchMap.size > 0) {
                        const firstBatchId = Array.from(batchMap.keys())[0];
                        const firstBatchImages = batchMap.get(firstBatchId);
                        
                        if (firstBatchImages && firstBatchImages.length > 0) {
                            // Sort by timestamp as index.html does
                            firstBatchImages.sort((a, b) => a.timestamp - b.timestamp);
                            const firstImage = firstBatchImages[0];
                            
                            log('Loading first image from first batch:', {
                                batchId: firstBatchId,
                                imageId: firstImage.id,
                                filename: firstImage.filename
                            });
                            
                            await loadImageById(firstImage.id);
                        } else {
                            log('No images found in first batch');
                            imageInfo.textContent = 'No valid images found in first batch.';
                        }
                    } else {
                        log('No image batches found');
                        imageInfo.textContent = 'No image batches found. Please load images in the main viewer first.';
                    }
                }
                
                // Enable transitions after page content has loaded
                setTimeout(() => {
                    document.body.classList.add('transitions-enabled');
                    log('Transitions enabled');
                }, 500);
            };
            
            // Execute the loading sequence
            loadingSequence();
            
                // Database monitoring already initialized earlier
        });
        
        // Toggle thumbnail panel
        function toggleThumbnailPanel() {
            thumbnailPanel.classList.toggle('active');
            document.getElementById('container').classList.toggle('with-thumbnails');
            
            // Update button text
            if (thumbnailPanel.classList.contains('active')) {
                toggleThumbnailsBtn.textContent = 'Hide Thumbnails';
                toggleHandle.classList.add('resize');
            } else {
                toggleThumbnailsBtn.textContent = 'Show Thumbnails';
                toggleHandle.classList.remove('resize');
            }
        }
        
        // Load thumbnails from IndexedDB
        async function loadThumbnails() {
            try {
                log('Loading thumbnails from IndexedDB');
                
                // Store collapsed states before clearing
                const collapsedBatchStates = new Map();
                document.querySelectorAll('.batch-header').forEach(header => {
                    const batchTitle = header.querySelector('.batch-title')?.textContent;
                    if (batchTitle) {
                        collapsedBatchStates.set(batchTitle, header.classList.contains('collapsed'));
                    }
                });
                
                // Clear existing thumbnails
                thumbnailsContainer.innerHTML = '';
                
                // Get all images from IndexedDB
                const allImages = await getAllImagesMetadata();
                
                if (!allImages || allImages.length === 0) {
                    log('No images found in IndexedDB');
                    thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images found</div>';
                    return;
                }
                
                log(`Found ${allImages.length} images in IndexedDB`);
                
                // Get the current image for highlighting the current selection
                let currentImageRecord = await getCurrentImage();
                let currentImageOriginalId = currentImageRecord?.originalId || null;
                
                log('Current image info:', {
                    id: currentImageRecord?.id || 'none',
                    originalId: currentImageOriginalId || 'none'
                });
                
                // Filter out the special current_image entry and ensure we only get images with blobs
                const filteredImages = allImages.filter(img => 
                    img.id !== CURRENT_IMAGE_KEY && // Never include current_image in thumbnails
                    img.hasBlob // Only include images with actual data
                );
                
                if (filteredImages.length === 0) {
                    thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images available</div>';
                    return;
                }
                
                log(`Found ${filteredImages.length} valid images for thumbnails`);
                
                // Group images by batch ID
                const batchMap = new Map();
                
                filteredImages.forEach(metadata => {
                    const batchId = metadata.batchId || 'default';
                    
                    if (!batchMap.has(batchId)) {
                        batchMap.set(batchId, []);
                    }
                    
                    batchMap.get(batchId).push(metadata);
                });
                
                // Create a batch element for each batch
                for (const [batchId, imagesList] of batchMap.entries()) {
                    // Sort images by timestamp
                    imagesList.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Create batch header
                    const batchHeader = document.createElement('div');
                    batchHeader.className = 'batch-header';
                    
                    // Create left side container for title and count
                    const leftSide = document.createElement('div');
                    leftSide.className = 'batch-info';
                    
                    // Create title
                    const title = document.createElement('span');
                    title.className = 'batch-title';
                    const batchNumber = batchMap.size > 1 ? Array.from(batchMap.keys()).indexOf(batchId) + 1 : '';
                    title.textContent = `Batch ${batchNumber}`;
                    leftSide.appendChild(title);
                    
                    // Add count badge
                    const count = document.createElement('span');
                    count.className = 'batch-count';
                    count.textContent = imagesList.length;
                    leftSide.appendChild(count);
                    
                    batchHeader.appendChild(leftSide);
                    
                    // Add chevron icon for expand/collapse
                    const chevron = document.createElement('span');
                    chevron.className = 'chevron';
                    chevron.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>';
                    batchHeader.appendChild(chevron);
                    
                    // Create batch content
                    const batchContent = document.createElement('div');
                    batchContent.className = 'batch-content';
                    
                    // Create reference between header and content elements
                    batchHeader.dataset.contentId = `batch-content-${batchId}`;
                    batchContent.id = `batch-content-${batchId}`;
                    
                    // Only apply collapsed state if explicitly found in the stored states
                    // Otherwise, default to expanded (not collapsed)
                    const wasCollapsed = collapsedBatchStates.has(title.textContent) && collapsedBatchStates.get(title.textContent) === true;
                    if (wasCollapsed) {
                        batchHeader.classList.add('collapsed');
                        batchContent.classList.add('collapsed');
                    }
                    
                    // Add toggle functionality
                    batchHeader.addEventListener('click', (event) => {
                        // Toggle collapsed class on this specific header
                        batchHeader.classList.toggle('collapsed');
                        
                        // Toggle collapsed class on the paired batch content using the reference
                        const contentId = batchHeader.dataset.contentId;
                        const content = document.getElementById(contentId);
                        if (content) {
                            content.classList.toggle('collapsed');
                        }
                        
                        // Log toggle action for debugging
                        log('Batch header toggled', {
                            batchTitle: title.textContent,
                            isCollapsed: batchHeader.classList.contains('collapsed'),
                            contentId
                        });
                        
                        // Prevent event bubbling
                        event.stopPropagation();
                    });
                    
                    thumbnailsContainer.appendChild(batchHeader);
                    
                    // Create thumbnails for each image
                    for (const imageMetadata of imagesList) {
                        const thumbnailItem = document.createElement('div');
                        
                        // Add special 'active' class for the image that matches the current image's originalId
                        if (currentImageOriginalId && imageMetadata.id === currentImageOriginalId) {
                            thumbnailItem.className = 'thumbnail-item active';
                        } else {
                            thumbnailItem.className = 'thumbnail-item';
                        }
                        
                        thumbnailItem.dataset.imageId = imageMetadata.id;
                        
                        // Match the index.html structure - img is direct child of thumbnail-item
                        const imgEl = document.createElement('img');
                        imgEl.alt = imageMetadata.filename;
                        imgEl.loading = 'lazy';
                        
                        // Use placeholder initially
                        const placeholderSrc = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiMxMTExMTEiLz48cGF0aCBkPSJNMzUgMjVINjVDNjguMyAyNSA3MSAyNy43IDcxIDMxVjY5QzcxIDcyLjMgNjguMyA3NSA2NSA3NUgzNUMzMS43IDc1IDI5IDcyLjMgMjkgNjlWMzFDMjkgMjcuNyAzMS43IDI1IDM1IDI1WiIgc3Ryb2tlPSIjNTU1IiBzdHJva2Utd2lkdGg9IjIiLz48Y2lyY2xlIGN4PSI0MCIgY3k9IjQwIiByPSI1IiBmaWxsPSIjNTU1Ii8+PHBhdGggZD0iTTMwIDYwTDQwIDUwTDUwIDYwTDYwIDUwTDcwIDYwVjcwSDMwVjYwWiIgZmlsbD0iIzU1NSIvPjwvc3ZnPg==';
                        imgEl.src = placeholderSrc;
                        
                        thumbnailItem.appendChild(imgEl);
                        
                        // Delete buttons removed from projection.html as it's read-only
                        
                        // Create a proper thumbnail label with filename
                        const label = document.createElement('div');
                        label.className = 'thumbnail-label';
                        label.textContent = imageMetadata.filename || 'Unnamed image';
                        thumbnailItem.appendChild(label);
                        
                        // Add click event to load the image
                        thumbnailItem.addEventListener('click', () => loadImageById(imageMetadata.id));
                        
                        batchContent.appendChild(thumbnailItem);
                        
                        // Load the actual thumbnail asynchronously
                        loadThumbnailImage(imageMetadata.id, imgEl);
                    }
                    
                    thumbnailsContainer.appendChild(batchContent);
                    
                    // Add divider after each batch except the last one
                    if (Array.from(batchMap.keys()).indexOf(batchId) < batchMap.size - 1) {
                        const divider = document.createElement('div');
                        divider.className = 'batch-divider';
                        thumbnailsContainer.appendChild(divider);
                    }
                }
                
                // Wait a moment for DOM to update, then ensure batch headers are visible
                setTimeout(() => {
                    document.querySelectorAll('.batch-header').forEach(header => {
                        // Ensure batch headers are properly styled
                        header.style.visibility = 'visible';
                        header.style.display = 'flex';
                        header.style.opacity = '1';
                    });
                    log('Batch headers refreshed and made visible');
                }, 50);
                
            } catch (error) {
                log('Error loading thumbnails', error.message);
                console.error('Error loading thumbnails:', error);
                thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">Error loading thumbnails</div>';
            }
        }
        
                // Load thumbnail image from database
        async function loadThumbnailImage(imageId, imgElement) {
            try {
                const imageRecord = await getImageFromDb(imageId);
                if (imageRecord && imageRecord.imageBlob) {
                    const objectUrl = URL.createObjectURL(imageRecord.imageBlob);
                    imgElement.src = objectUrl;
                    
                    // Store the objectUrl on the parent thumbnail item for proper cleanup
                    const thumbnailItem = imgElement.closest('.thumbnail-item');
                    if (thumbnailItem) {
                        thumbnailItem.dataset.objectUrl = objectUrl;
                    } else {
                        imgElement.dataset.objectUrl = objectUrl;
                    }
                }
            } catch (error) {
                console.error(`Error loading thumbnail for image ${imageId}:`, error);
            }
        }
        
        // Load image by ID from IndexedDB
        async function loadImageById(imageId) {
            if (!imageId) {
                log('No image ID provided');
                return;
            }
            
            log(`Loading image ${imageId} from IndexedDB`);
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Loading image...';
            
            try {
                // Get the image from IndexedDB
                const imageRecord = await getImageFromDb(imageId);
                
                if (!imageRecord) {
                    log(`Image ${imageId} not found in IndexedDB`);
                    imageInfo.textContent = `Error: Image with ID ${imageId} not found.`;
                    loadingIndicator.style.display = 'none';
                    return;
                }
                
                // Store current image ID for tracking
                currentImageId = imageId;
                currentImageRecord = imageRecord;
                
                // Create an image element from the blob
                const img = await createImageFromRecord(imageRecord);
                
                // Import the renderImage function
                const { getCanvas, getContext, clearCanvas } = await import('./src/ui/canvas/canvasContext.js');
                const { setState } = await import('./src/core/projectionState.js');
                
                // Store the image in state
                setState({ image: img });
                
                // Size the canvas to match the image dimensions
                const canvas = getCanvas();
                if (canvas) {
                    canvas.width = img.naturalWidth || imageRecord.dimensions.width;
                    canvas.height = img.naturalHeight || imageRecord.dimensions.height;
                }
                
                // Clear and render to the canvas
                clearCanvas('#222');
                
                // Draw the image when it's loaded
                const ctx = getContext();
                if (ctx && img) {
                    img.onload = function() {
                        ctx.drawImage(img, 0, 0);
                    };
                    
                    // If already loaded, draw immediately
                    if (img.complete) {
                        ctx.drawImage(img, 0, 0);
                    }
                }
                
                // Keep the img element updated as well (though hidden)
                imageDisplay.src = img.src;
                
                // Update image info
                imageInfo.innerHTML = `
                    <strong>Image loaded successfully</strong><br>
                    ID: ${imageRecord.id}<br>
                    Filename: ${imageRecord.filename}<br>
                    Size: ${imageRecord.dimensions.width} x ${imageRecord.dimensions.height} px<br>
                    File Type: ${imageRecord.fileType || 'Unknown'}<br>
                    File Size: ${imageRecord.imageBlob.size ? formatFileSize(imageRecord.imageBlob.size) : 'Unknown'}<br>
                    Last Modified: ${new Date(imageRecord.timestamp).toLocaleString()}
                `;
                
                // Set this image as the current image in database (for the main viewer to access)
                await setCurrentImageInDatabase(imageRecord);
                
                // Highlight the selected thumbnail
                const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                thumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('active');
                    if (thumbnail.dataset.imageId === imageId) {
                        thumbnail.classList.add('active');
                        // Scroll to the selected thumbnail
                        thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
                
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
                
            } catch (error) {
                log('Error loading image:', error.message);
                console.error('Error loading image:', error);
                imageInfo.textContent = `Error loading image: ${error.message}`;
                loadingIndicator.style.display = 'none';
            }
        }
        
        /**
         * Set the current image in the database for cross-page access
         * This function updates the current_image in the dedicated store
         */
        async function setCurrentImageInDatabase(imageRecord) {
            if (!imageRecord || !imageRecord.imageBlob) {
                log('Cannot set current image: invalid record or missing blob');
                return false;
            }
            
            try {
                log('Setting current image in database for main viewer', {
                    id: imageRecord.id,
                    filename: imageRecord.filename
                });
                
                // Import and use saveCurrentImage directly
                const { saveCurrentImage } = await import('./src/services/db/currentImageStore.js');
                
                // Save to dedicated current image store with original ID reference
                await saveCurrentImage(null, null, {
                    ...imageRecord,
                    selectedFile: imageRecord.imageBlob,
                    originalId: imageRecord.id  // Store the original ID for reference
                });
                
                log('Current image set successfully in database');
                
                return true;
            } catch (error) {
                log('Error setting current image in database:', error.message);
                console.error('Error setting current image in database:', error);
                return false;
            }
        }
        
        // Set up button handlers
        loadButton.addEventListener('click', loadCurrentImage);
        document.getElementById('loadAllImages').addEventListener('click', loadAllImagesFromDb);
        document.getElementById('clear-db-btn').addEventListener('click', clearDatabase);
        backButton.addEventListener('click', () => {
            window.location.href = 'index.html';
        });
        
        // Toggle debug info
        showDebugButton.addEventListener('click', () => {
            if (debugLog.style.display === 'none') {
                debugLog.style.display = 'block';
                showDebugButton.textContent = 'Hide Debug Info';
            } else {
                debugLog.style.display = 'none';
                showDebugButton.textContent = 'Show Debug Info';
            }
        });
        
        // Apply a simple visual processing effect as a demo
        applyProcessingButton.addEventListener('click', () => {
            if (!imageDisplay.src || imageDisplay.src.endsWith('No image loaded')) {
                alert('Please load an image first');
                return;
            }
            
            applyDemoProcessing();
        });
        
        // Load the current image from IndexedDB
        async function loadCurrentImage() {
            try {
                // Show loading indicator
                loadingIndicator.style.display = 'flex';
                loadingIndicator.textContent = 'Loading image from IndexedDB...';
                
                log('Requesting image from IndexedDB');
                
                // Get the current image from IndexedDB
                const imageRecord = await getCurrentImage();
                
                if (!imageRecord) {
                    log('No image record found in IndexedDB');
                    imageInfo.textContent = 'No image found in storage. Please load an image in the main viewer first.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                log('Retrieved image record', {
                    id: imageRecord.id,
                    filename: imageRecord.filename,
                    hasBlobData: !!imageRecord.imageBlob,
                    blobSize: imageRecord.imageBlob?.size,
                    dimensions: imageRecord.dimensions,
                    originalId: imageRecord.originalId || 'none'
                });
                
                // Store the current image ID for sync detection
                currentImageId = imageRecord.id;
                currentImageRecord = imageRecord;
                
                if (!imageRecord.imageBlob) {
                    log('Error: Image record has no blob data');
                    imageInfo.textContent = 'Error: Image record exists but contains no image data.';
                    loadingIndicator.style.display = 'none';
                    return false;
                }
                
                // Check if this record points to an original image
                // In index.html's approach, the current_image might store the original image's ID
                if (imageRecord.originalId) {
                    log(`Current image points to original image with ID: ${imageRecord.originalId}`);
                    
                    // Update thumbnails to highlight the original image
                    const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                    thumbnails.forEach(thumbnail => {
                        thumbnail.classList.remove('active');
                        
                        // Highlight the original image this current_image points to
                        if (thumbnail.dataset.imageId === imageRecord.originalId) {
                            thumbnail.classList.add('active');
                            // Scroll to the selected thumbnail
                            thumbnail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    });
                } else {
                    // Reset thumbnail selection when no original ID exists
                    const thumbnails = thumbnailsContainer.querySelectorAll('.thumbnail-item');
                    thumbnails.forEach(thumbnail => {
                        thumbnail.classList.remove('active');
                    });
                }
                
                // Create an image element from the blob
                log('Creating image element from blob', {
                    type: imageRecord.imageBlob.type,
                    size: imageRecord.imageBlob.size
                });
                
                const img = await createImageFromRecord(imageRecord);
                log('Image created from blob', {
                    width: img.width,
                    height: img.height,
                    complete: img.complete
                });
                
                // Import the renderImage function
                const { getCanvas, getContext, clearCanvas } = await import('./src/ui/canvas/canvasContext.js');
                const { setState } = await import('./src/core/projectionState.js');
                
                // Store the image in state
                setState({ image: img });
                
                // Size the canvas to match the image dimensions
                const canvas = getCanvas();
                if (canvas) {
                    canvas.width = img.naturalWidth || imageRecord.dimensions.width;
                    canvas.height = img.naturalHeight || imageRecord.dimensions.height;
                }
                
                // Clear and render to the canvas
                clearCanvas('#222');
                
                // Draw the image when it's loaded
                const ctx = getContext();
                if (ctx && img) {
                    img.onload = function() {
                        ctx.drawImage(img, 0, 0);
                    };
                    
                    // If already loaded, draw immediately
                    if (img.complete) {
                        ctx.drawImage(img, 0, 0);
                    }
                }
                
                // Keep the img element updated as well (though hidden)
                imageDisplay.src = img.src;
                
                // Don't wait for onload event - set up info immediately
                log('Image being displayed', {
                    naturalWidth: img.naturalWidth,
                    naturalHeight: img.naturalHeight
                });
                
                // Update image info
                imageInfo.innerHTML = `
                    <strong>Image loaded successfully</strong><br>
                    ${imageRecord.id === CURRENT_IMAGE_KEY ? '<span style="color: #ff9800; font-weight: bold;">Current image from main viewer</span><br>' : ''}
                    Filename: ${imageRecord.filename}<br>
                    Size: ${imageRecord.dimensions.width} x ${imageRecord.dimensions.height} px<br>
                    File Type: ${imageRecord.fileType || 'Unknown'}<br>
                    File Size: ${imageRecord.imageBlob.size ? formatFileSize(imageRecord.imageBlob.size) : 'Unknown'}<br>
                    Last Modified: ${new Date(imageRecord.timestamp).toLocaleString()}
                    ${imageRecord.originalId ? '<br><em>(From main viewer)</em>' : ''}
                `;
                
                loadingIndicator.style.display = 'none';
                return true;
                
            } catch (error) {
                log('Error loading image from IndexedDB', error.message);
                console.error('Error loading image from IndexedDB:', error);
                imageInfo.textContent = `Error loading image: ${error.message}`;
                loadingIndicator.style.display = 'none';
                return false;
            }
        }
        
        // Load all images from IndexedDB
        async function loadAllImagesFromDb() {
            log('Loading all images from database');
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Loading all images...';
            
            try {
                // Get all images metadata
                const allImages = await getAllImagesMetadata();
                
                if (!allImages || allImages.length === 0) {
                    log('No images found in database');
                    imageInfo.textContent = 'No images found in database.';
                    loadingIndicator.style.display = 'none';
                    return;
                }
                
                log(`Found ${allImages.length} images in database`);
                
                // Group images by batch ID to match index.html's structure
                const batchMap = new Map();
                
                // Track filenames to prevent duplication
                const processedFilenames = new Set();
                
                // Organize images into batches, similar to index.html
                for (const metadata of allImages) {
                    // Skip the current_image record
                    if (metadata.id === CURRENT_IMAGE_KEY) continue;
                    if (!metadata.hasBlob) continue;
                    
                    const batchId = metadata.batchId || 'default';
                    const filename = metadata.filename;
                    
                    // Skip duplicates
                    if (processedFilenames.has(filename)) continue;
                    processedFilenames.add(filename);
                    
                    if (!batchMap.has(batchId)) {
                        batchMap.set(batchId, []);
                    }
                    
                    batchMap.get(batchId).push(metadata);
                }
                
                // Reset thumbnails
                await loadThumbnails();
                
                // Find the first image in the first batch - same logic as index.html
                let firstImage = null;
                let firstBatchId = null;
                
                if (batchMap.size > 0) {
                    // Find the first batch and its first image
                    firstBatchId = Array.from(batchMap.keys())[0];
                    const firstBatchImages = batchMap.get(firstBatchId);
                    
                    if (firstBatchImages && firstBatchImages.length > 0) {
                        // Sort by timestamp as index.html does
                        firstBatchImages.sort((a, b) => a.timestamp - b.timestamp);
                        firstImage = firstBatchImages[0];
                    }
                }
                
                if (firstImage) {
                    log('Loading first image from first batch:', {
                        batchId: firstBatchId,
                        imageId: firstImage.id,
                        filename: firstImage.filename
                    });
                    loadImageById(firstImage.id);
                } else {
                    log('No valid images found in batches');
                    imageInfo.textContent = 'No valid images found in database.';
                    loadingIndicator.style.display = 'none';
                }
            } catch (error) {
                log('Error loading all images', error.message);
                console.error('Error loading all images:', error);
                imageInfo.textContent = `Error loading images: ${error.message}`;
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Apply a simple visual effect to demonstrate image processing
        async function applyDemoProcessing() {
            // Import canvas utilities
            const { getCanvas, getContext } = await import('./src/ui/canvas/canvasContext.js');
            const { getState } = await import('./src/core/projectionState.js');
            
            // Get the canvas
            const canvas = getCanvas();
            if (!canvas) {
                alert('Canvas element not found');
                return;
            }
            
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Applying demo processing...';
            log('Starting image processing');
            
            setTimeout(() => {
                try {
                    // Get the context from the main canvas
                    const ctx = getContext();
                    
                    if (!ctx) {
                        throw new Error('Could not get canvas context');
                    }
                    
                    // Check if canvas has content
                    if (canvas.width === 0 || canvas.height === 0) {
                        throw new Error('Canvas has no dimensions - please load an image first');
                    }
                    
                    log('Processing canvas', {
                        width: canvas.width,
                        height: canvas.height
                    });
                    
                    // Get the image data directly from the main canvas
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    log('Processing image data', {
                        pixelCount: data.length / 4
                    });
                    
                    // Invert all colors as a simple demo effect
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];         // Red
                        data[i + 1] = 255 - data[i + 1]; // Green
                        data[i + 2] = 255 - data[i + 2]; // Blue
                        // data[i + 3] is alpha (transparency)
                    }
                    
                    // Put the modified image data back to the canvas
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Keep the hidden img element in sync
                    imageDisplay.src = canvas.toDataURL();
                    
                    // Update information
                    imageInfo.innerHTML += '<br><strong>Status: Processed (colors inverted)</strong>';
                    log('Image processing complete');
                } catch (error) {
                    log('Error applying processing', error.message);
                    console.error('Error applying processing:', error);
                    alert('Error applying processing: ' + error.message);
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            }, 500); // Small delay to allow the loading indicator to display
        }
        
        // Helper function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Clear all images from IndexedDB
        async function clearDatabase() {
            log('Clearing image database...');
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            loadingIndicator.textContent = 'Clearing database...';
            
            try {
                // Clear the database without confirmation
                await clearImageDatabase();
                
                // Clear the current display
                imageDisplay.src = '';
                imageInfo.textContent = 'Database cleared. No images loaded.';
                
                // Clear thumbnails
                thumbnailsContainer.innerHTML = '<div class="empty-thumbnail-state">No images found</div>';
                
                // Log success message to debug panel
                log('Database cleared successfully');
                
            } catch (error) {
                log('Error clearing database:', error.message);
                console.error('Error clearing database:', error);
            } finally {
                // Hide loading indicator
                loadingIndicator.style.display = 'none';
            }
        }
        
        // Clean up resources when page unloads
        window.addEventListener('beforeunload', () => {
            // Revoke all object URLs
            document.querySelectorAll('[data-object-url]').forEach(el => {
                if (el.dataset.objectUrl) {
                    URL.revokeObjectURL(el.dataset.objectUrl);
                }
            });
        });
        
        let lastImageCount = 0;
        let lastDatabaseTimestamp = 0;
        let currentImageId = null;
        let currentImageTimestamp = 0;
        const syncStatusIndicator = document.getElementById('syncStatus');

// This function is no longer needed as we directly use initializeMonitoring

// Constants for database monitoring    
        const CHECK_INTERVAL = 2000; // Check every 2 seconds
        const CURRENT_IMAGE_KEY = 'current_image'; // Special key for the current image in the database

        // Variables for state tracking
let lastCurrentImageTimestamp = 0;
let lastKnownImageCount = 0;
        
        // Handle database changes detected by the monitoring system
        async function handleDatabaseChanges(changeInfo) {
            log('Received database change notification:', changeInfo);
            
            // If data was refreshed by the monitoring system
            if (changeInfo.dataRefreshed) {
                log('Database was refreshed, updating display...');
                
                // Reload thumbnails
                await loadThumbnails();
                
                // Try to load current image, and if not available, load the first image
                const currentImageLoaded = await loadCurrentImage();
                
                if (!currentImageLoaded) {
                    log('No current image after refresh, loading first available image...');
                    await loadAllImagesFromDb();
                }
                
                return;
            }
            
            // Handle other specific changes
            if (changeInfo.currentImageChanged) {
                log('Current image changed, reloading...');
                await loadCurrentImage();
            }
            
            if (changeInfo.batchCountChanged || changeInfo.imageCountChanged) {
                log('Image collection changed, updating thumbnails...');
                await loadThumbnails();
            }
        }

        // Initialize our local monitoring system
function initializeMonitoring() {
    log('Initializing database monitoring system');
    
    // Register our change handler callback
    registerChangeObserver(handleDatabaseChanges);
    
    // Set up visual indicator for sync status
    function updateSyncIndicator(isActive) {
        if (isActive) {
            syncStatusIndicator.classList.add('active');
        } else {
            syncStatusIndicator.classList.remove('active');
        }
    }
    
    // Show sync indicator briefly every few seconds
    setInterval(() => {
        updateSyncIndicator(true);
        setTimeout(() => updateSyncIndicator(false), 500);
    }, 5000);
    
    // Start the imported monitoring system
    startDbMonitoring();
    
    // Clean up when page unloads
    window.addEventListener('unload', () => {
        unregisterChangeObserver(handleDatabaseChanges);
    });
    
    log('Database monitoring initialized');
}
        
        // Store the current image record
        let currentImageRecord = null;
        
        function getCurrentImageRecord() {
            return currentImageRecord;
        }
        
        // Check for database changes
async function checkForDbChanges() {
    // This function is now a stub that's kept for backwards compatibility
    // Actual change detection is now handled by the observer pattern via handleDatabaseChanges
    // This helps prevent circular dependencies with the core app.js
    
    try {
        // Update timestamps to track last known state
        const currentImage = await getCurrentImage();
        if (currentImage && currentImage.timestamp) {
            lastCurrentImageTimestamp = currentImage.timestamp;
        }
        
        // Count images to detect count changes next time
        const allMetadata = await getAllImagesMetadata();
        const regularImages = allMetadata ? allMetadata.filter(img => 
            img.id !== CURRENT_IMAGE_KEY && img.hasBlob
        ).length : 0;
        
        lastKnownImageCount = regularImages;
    } catch (error) {
        log('Error in database check:', error.message);
    }
}
</script>
</body>
</html> 