<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thumbnail Pane Shadow DOM Test</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-color: #222;
            color: #eee;
            display: flex;
            height: 100vh;
            overflow: hidden; /* Prevent body scrollbars */
        }
        /* This will be our main content area, pushed by the panel */
        #main-content {
            flex-grow: 1;
            padding: 20px;
            background-color: #333;
            transition: margin-left 0.25s ease; /* Match panel animation */
            height: 100%;
            box-sizing: border-box;
            overflow-y: auto;
            position: relative; /* Added for canvas positioning */
        }
        /* Style for when the panel is active */
        body.thumbnail-panel-active #main-content {
            /* Adjusted by JS based on panel width */
        }
        #toggle-panel-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            margin-bottom: 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #toggle-panel-btn:hover {
            background-color: #45a049;
        }
        #centered-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            /* width and height will be set by JS */
            transform: translate(-50%, -50%);
            border: 2px solid #00ffff; /* Neon blue */
            box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff; /* Neon glow effect */
            background-color: rgba(0,0,0,0.1); /* Slight background for visibility */
        }
    </style>
    <script type="module" src="thumbnail-pane.js"></script>
</head>
<body>
    <thumbnail-pane id="my-thumbnail-panel" opened></thumbnail-pane>
    <div id="main-content">
        <button id="toggle-panel-btn">Toggle Panel</button>
        <h1>Main Content Area</h1>
        <p>This area will be pushed when the thumbnail panel is open.</p>
        <p>The thumbnail panel should appear to the left.</p>
        <canvas id="centered-canvas"></canvas>
    </div>

    <script type="module">
        const panel = document.getElementById('my-thumbnail-panel');
        const mainContent = document.getElementById('main-content');
        const toggleButton = document.getElementById('toggle-panel-btn');
        const canvas = document.getElementById('centered-canvas');
        let ctx = canvas.getContext('2d');

        const MOCK_IMAGE_WIDTH = 800;
        const MOCK_IMAGE_HEIGHT = 600;

        function resizeAndPositionCanvas() {
            if (!canvas || !mainContent) return;

            // Use clientWidth/clientHeight which give dimensions of content + padding
            const mainContentWidth = mainContent.clientWidth;
            const mainContentHeight = mainContent.clientHeight;

            const largerParentDim = Math.max(mainContentWidth, mainContentHeight);
            // 20% (original) * 1.1 (10% larger) = 22%
            const canvasSideLength = largerParentDim * 0.22; 

            canvas.style.width = canvasSideLength + 'px';
            canvas.style.height = canvasSideLength + 'px';
            // When canvas CSS dimensions change, its drawing surface dimensions need to be updated too.
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            // Redraw content if any was on canvas, or clear for next draw.
            // For now, let's ensure it's cleared if we resize.
            if (ctx) { // ctx might not be initialized if this runs too early for some reason
                clearCanvasAndDrawMessage("Canvas resized. Select an image.");
            }
        }

        panel.addEventListener('panel-opened', () => {
            document.body.classList.add('thumbnail-panel-active');
            mainContent.style.marginLeft = panel.getCurrentWidth() + 'px';
            toggleButton.textContent = 'Close Panel';
            resizeAndPositionCanvas();
        });

        panel.addEventListener('panel-closed', () => {
            document.body.classList.remove('thumbnail-panel-active');
            mainContent.style.marginLeft = '0px';
            toggleButton.textContent = 'Open Panel';
            resizeAndPositionCanvas();
        });

        toggleButton.addEventListener('click', () => {
            panel.togglePanel();
        });

        // Initial state sync for the button text if panel is pre-opened
        if (panel.hasAttribute('opened')) {
            // Dispatch an event or call directly if the panel is already open due to the attribute
            // For simplicity, we can assume the panel will fire 'panel-opened' if it starts opened.
            // Or, more robustly:
            if (panel._isPanelActive || panel.classList.contains('active')) { // Check internal state or class
                 document.body.classList.add('thumbnail-panel-active');
                 mainContent.style.marginLeft = panel.getCurrentWidth() + 'px';
                 toggleButton.textContent = 'Close Panel';
            } else {
                 toggleButton.textContent = 'Open Panel';
            }
        } else {
            toggleButton.textContent = 'Open Panel';
        }
        
        // Initial canvas sizing after DOM is ready and on window resize
        // Use a timeout to ensure layout calculations are complete for mainContent dimensions
        setTimeout(() => {
            resizeAndPositionCanvas(); // This will also set canvas.width and canvas.height
            clearCanvasAndDrawMessage("Select an image from the panel.");
        }, 0);
        window.addEventListener('resize', resizeAndPositionCanvas);

        function clearCanvasAndDrawMessage(message) {
            if (!ctx || !canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (message) {
                ctx.fillStyle = 'rgba(238, 238, 238, 0.7)'; // Semi-transparent white/light gray
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Basic font styling
                const fontSize = Math.min(canvas.width / 20, canvas.height / 10, 16);
                ctx.font = `${fontSize}px sans-serif`;
                ctx.fillText(message, canvas.width / 2, canvas.height / 2);
            }
        }

        // Listen for item selection from the thumbnail panel
        panel.addEventListener('thumbnail-selected', (event) => {
            console.log('Received thumbnail-selected. Event detail:', event.detail);

            if (!ctx || !canvas) {
                console.error('Canvas or context not available for drawing.');
                return;
            }
            
            let itemName, itemType;

            // Access item details from event.detail.file
            if (event.detail && event.detail.file && 
                typeof event.detail.file.name === 'string' && 
                typeof event.detail.file.type === 'string') {
                itemName = event.detail.file.name;
                itemType = event.detail.file.type;
            } else {
                console.warn('Received incomplete or unexpectedly structured item data from thumbnail-selected event. Expected event.detail.file.name and event.detail.file.type. Event detail:', event.detail);
                clearCanvasAndDrawMessage("Error: Incomplete item data.");
                return;
            }

            clearCanvasAndDrawMessage(null); // Clear canvas before drawing new item

            if (itemType.startsWith('image/')) {
                const fileData = event.detail.file.data; // This should be the File object

                if (fileData instanceof File) {
                    const image = new Image();
                    const imageUrl = URL.createObjectURL(fileData);
                    
                    image.onload = () => {
                        clearCanvasAndDrawMessage(null); // Clear before drawing final image
                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;
                        const imgNaturalWidth = image.naturalWidth;
                        const imgNaturalHeight = image.naturalHeight;

                        const scaleX = canvasWidth / imgNaturalWidth;
                        const scaleY = canvasHeight / imgNaturalHeight;
                        const scale = Math.min(scaleX, scaleY, 1); // Ensure image is not scaled up if smaller than canvas

                        const drawnWidth = imgNaturalWidth * scale;
                        const drawnHeight = imgNaturalHeight * scale;

                        const dx = (canvasWidth - drawnWidth) / 2;
                        const dy = (canvasHeight - drawnHeight) / 2;

                        ctx.drawImage(image, dx, dy, drawnWidth, drawnHeight);
                        URL.revokeObjectURL(imageUrl); // Clean up the object URL
                    };
                    image.onerror = () => {
                        console.error(`Error loading image for canvas: ${itemName}`);
                        clearCanvasAndDrawMessage(`Error loading: ${itemName}`);
                        URL.revokeObjectURL(imageUrl); // Clean up the object URL
                    };
                    image.src = imageUrl;
                } else {
                    // Fallback for items without actual File data (e.g., initial setData items)
                    // Draw the placeholder rectangle and filename as before.
                    const MOCK_IMAGE_WIDTH = 800; 
                    const MOCK_IMAGE_HEIGHT = 600;
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;

                    const scaleX = canvasWidth / MOCK_IMAGE_WIDTH;
                    const scaleY = canvasHeight / MOCK_IMAGE_HEIGHT;
                    const scale = Math.min(scaleX, scaleY);

                    const drawnWidth = MOCK_IMAGE_WIDTH * scale;
                    const drawnHeight = MOCK_IMAGE_HEIGHT * scale;

                    const dx = (canvasWidth - drawnWidth) / 2;
                    const dy = (canvasHeight - drawnHeight) / 2;

                    ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.fillRect(dx, dy, drawnWidth, drawnHeight);
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
                    ctx.strokeRect(dx, dy, drawnWidth, drawnHeight);

                    ctx.fillStyle = '#eee';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let fontSize = Math.min(drawnWidth / (itemName.length * 0.6), drawnHeight / 3, 16);
                    if (itemName.length > 25) fontSize = Math.min(fontSize, 12);
                    if (fontSize < 8) fontSize = 8; 
                    
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.fillText(itemName, dx + drawnWidth / 2, dy + drawnHeight / 2);
                }
            } else {
                // Not an image type
                clearCanvasAndDrawMessage(`Preview not available for: ${itemName} (${itemType})`);
            }
        });

        // Listen for paste events on the document
        document.addEventListener('paste', async (event) => {
            console.log('Document paste event detected');
            const items = event.clipboardData?.items;
            if (!items) {
                console.log('No clipboard items found.');
                return;
            }

            const imageFiles = [];
            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        console.log('Pasted image file (from document):', file.name, file.type);
                        imageFiles.push(file);
                    }
                }
            }

            if (imageFiles.length > 0) {
                event.preventDefault(); // Prevent default paste action only if we are handling images
                // Call the component's more generic public method
                panel.createNewBatch(imageFiles, { title: "Pasted Images" }); 
                console.log('Called panel.createNewBatch with', imageFiles.length, 'files');
            } else {
                console.log('No image files found in document paste data to forward to panel.');
            }
        });

        // Example: Set some initial data
        panel.setData([
            { 
                id: 'batch1', 
                title: 'Batch 001 - Mixed Files', 
                expanded: true, 
                files: [
                    { name: 'image_landscape.jpg', type: 'image/jpeg' }, 
                    { name: 'document_report.pdf', type: 'application/pdf' }, 
                    { name: 'image_portrait.png', type: 'image/png' },
                    { name: 'important_notes.tiff', type: 'image/tiff' } // Will use SVG placeholder
                ]
            },
            { 
                id: 'batch2', 
                title: 'Batch 002 - More Images', 
                expanded: true, // Let's expand this one too for the demo
                files: [
                    { name: 'photo_A_really_long_name_that_should_be_truncated.png', type: 'image/png' },
                    { name: 'photo_B.gif', type: 'image/gif' },
                    { name: 'photo_C.jpeg', type: 'image/jpeg' }
                ]
            },
            { 
                id: 'batch3', 
                title: 'Batch 003 - Empty', 
                expanded: true, 
                files: []
            },
            { 
                id: 'batch4', 
                title: 'Batch 004 - Collapsed', 
                expanded: false, 
                files: [
                    { name: 'another_image.jpg', type: 'image/jpeg' },
                    { name: 'secret_document.pdf', type: 'application/pdf' }
                ]
            }
        ]);

    </script>
</body>
</html> 